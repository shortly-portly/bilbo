{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$state_inline.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_inline/state_inline.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$state_inline\"] = function(global,require,module,exports) {\n// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n\n};"],
"names":["shadow$provide","global","require","module","exports","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","Token","isWhiteSpace","isPunctChar","isMdAsciiPunct","prototype","pushPending","StateInline.prototype.pushPending","token","content","push","StateInline.prototype.push","type","tag","nesting","token_meta","pop","scanDelims","StateInline.prototype.scanDelims","start","canSplitWord","lastChar","can_close","right_flanking","left_flanking","max","marker","charCodeAt","count","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","can_open"]
}
