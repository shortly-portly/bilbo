{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_block$paragraph.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,0DAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAMtHD,MAAAC,QAAA,CAAiBC,QAAkB,CAACC,KAAD,CAAQC,SAAR,CAAgC,CAAA,IACtCC,CACvBC,KAAAA,MAAWF,SAAXE,CAAuB,CAFsC,KAG7DC,gBAAkBJ,KAAAK,GAAAC,MAAAC,MAAAC,SAAA,CAA8B,WAA9B,CAH2C,CAI7DC,QAAUT,KAAAU,QAEd,KAAAC,cAAgBX,KAAAY,WAIhB,KAHAZ,KAAAY,WAGA,CAHmB,WAGnB,CAAOT,KAAP,CAAkBM,OAAlB,EAA6B,CAACT,KAAAa,QAAA,CAAcV,KAAd,CAA9B,CAAuDA,KAAA,EAAvD,CAGE,GAAI,EAA2C,CAA3C,CAAAH,KAAAc,OAAA,CAAaX,KAAb,CAAA,CAAyBH,KAAAe,UAAzB,EAGyB,CAHzB,CAGAf,KAAAc,OAAA,CAAaX,KAAb,CAHA,CAAJ,CAGA,CAGA,IAAAa,QAAY,CAAA,CACP,KAAAC,EAAI,CAAT,KAAYf,CAAZ,CAAgBE,eAAAc,OAAhB,CAAwCD,CAAxC;AAA4Cf,CAA5C,CAA+Ce,CAAA,EAA/C,CACE,GAAIb,eAAA,CAAgBa,CAAhB,CAAA,CAAmBjB,KAAnB,CAA0BG,KAA1B,CAAoCM,OAApC,CAA6C,CAAA,CAA7C,CAAJ,CAAwD,CACtDO,OAAA,CAAY,CAAA,CACZ,MAFsD,CAK1D,GAAIA,OAAJ,CAAiB,KAVjB,CAaFG,OAAA,CAAUnB,KAAAoB,SAAA,CAAenB,SAAf,CAA0BE,KAA1B,CAAoCH,KAAAe,UAApC,CAAqD,CAAA,CAArD,CAAAM,KAAA,EAEVrB,MAAAsB,KAAA,CAAanB,KAEboB,MAAA,CAAiBvB,KAAAwB,KAAA,CAAW,gBAAX,CAA6B,GAA7B,CAAkC,CAAlC,CACjBD,MAAAE,IAAA,CAAiB,CAAExB,SAAF,CAAaD,KAAAsB,KAAb,CAEjBC,MAAA,CAAiBvB,KAAAwB,KAAA,CAAW,QAAX,CAAqB,EAArB,CAAyB,CAAzB,CACjBD,MAAAJ,QAAA,CAAiBA,OACjBI,MAAAE,IAAA,CAAiB,CAAExB,SAAF,CAAaD,KAAAsB,KAAb,CACjBC,MAAAG,SAAA,CAAiB,EAEA1B,MAAAwB,KAAA,CAAW,iBAAX,CAA8B,GAA9B,CAAmC,EAAnC,CAEjBxB,MAAAY,WAAA,CAAmBD,aAEnB,OAAO,CAAA,CA7C0D,CANmD;",
"sources":["node_modules/markdown-it/lib/rules_block/paragraph.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$paragraph\"] = function(global,require,module,exports) {\n// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","module.exports","state","startLine","l","nextLine","terminatorRules","md","block","ruler","getRules","endLine","lineMax","oldParentType","parentType","isEmpty","sCount","blkIndent","terminate","i","length","content","getLines","trim","line","token","push","map","children"]
}
