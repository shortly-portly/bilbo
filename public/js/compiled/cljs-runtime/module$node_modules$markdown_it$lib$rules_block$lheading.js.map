{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_block$lheading.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_block/lheading.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$lheading\"] = function(global,require,module,exports) {\n// lheading (---, ===)\n\n'use strict';\n\n\nmodule.exports = function lheading(state, startLine, endLine/*, silent*/) {\n  var content, terminate, i, l, token, pos, max, level, marker,\n      nextLine = startLine + 1, oldParentType,\n      terminatorRules = state.md.block.ruler.getRules('paragraph');\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph'; // use paragraph to match terminatorRules\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    //\n    // Check for underline in setext header\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n\n      if (pos < max) {\n        marker = state.src.charCodeAt(pos);\n\n        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {\n          pos = state.skipChars(pos, marker);\n          pos = state.skipSpaces(pos);\n\n          if (pos >= max) {\n            level = (marker === 0x3D/* = */ ? 1 : 2);\n            break;\n          }\n        }\n      }\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  if (!level) {\n    // Didn't find valid underline\n    return false;\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine + 1;\n\n  token          = state.push('heading_open', 'h' + String(level), 1);\n  token.markup   = String.fromCharCode(marker);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line - 1 ];\n  token.children = [];\n\n  token          = state.push('heading_close', 'h' + String(level), -1);\n  token.markup   = String.fromCharCode(marker);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","module.exports","state","startLine","endLine","l","nextLine","terminatorRules","md","block","ruler","getRules","sCount","blkIndent","oldParentType","parentType","isEmpty","pos","bMarks","tShift","max","eMarks","marker","src","charCodeAt","skipChars","skipSpaces","level","terminate","i","length","content","getLines","trim","line","token","push","String","markup","fromCharCode","map","children"]
}
