["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/parser_block.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$parser_block=function(global,require,module,exports){function ParserBlock(){this.ruler=new Ruler;for(var i=0;i<_rules.length;i++)this.ruler.push(_rules[i][0],_rules[i][1],{alt:(_rules[i][2]||[]).slice()})}var Ruler=require(\"module$node_modules$markdown_it$lib$ruler\"),_rules=[[\"table\",require(\"module$node_modules$markdown_it$lib$rules_block$table\"),[\"paragraph\",\"reference\"]],[\"code\",require(\"module$node_modules$markdown_it$lib$rules_block$code\")],\n[\"fence\",require(\"module$node_modules$markdown_it$lib$rules_block$fence\"),[\"paragraph\",\"reference\",\"blockquote\",\"list\"]],[\"blockquote\",require(\"module$node_modules$markdown_it$lib$rules_block$blockquote\"),[\"paragraph\",\"reference\",\"blockquote\",\"list\"]],[\"hr\",require(\"module$node_modules$markdown_it$lib$rules_block$hr\"),[\"paragraph\",\"reference\",\"blockquote\",\"list\"]],[\"list\",require(\"module$node_modules$markdown_it$lib$rules_block$list\"),[\"paragraph\",\"reference\",\"blockquote\"]],[\"reference\",require(\"module$node_modules$markdown_it$lib$rules_block$reference\")],\n[\"heading\",require(\"module$node_modules$markdown_it$lib$rules_block$heading\"),[\"paragraph\",\"reference\",\"blockquote\"]],[\"lheading\",require(\"module$node_modules$markdown_it$lib$rules_block$lheading\")],[\"html_block\",require(\"module$node_modules$markdown_it$lib$rules_block$html_block\"),[\"paragraph\",\"reference\",\"blockquote\"]],[\"paragraph\",require(\"module$node_modules$markdown_it$lib$rules_block$paragraph\")]];ParserBlock.prototype.tokenize=function(state,startLine,endLine){for(var i,rules=this.ruler.getRules(\"\"),\nlen=rules.length,line=startLine,hasEmptyLines=!1,maxNesting=state.md.options.maxNesting;line<endLine;){state.line=line=state.skipEmptyLines(line);if(line>=endLine)break;if(state.sCount[line]<state.blkIndent)break;if(state.level>=maxNesting){state.line=endLine;break}for(i=0;i<len&&!(startLine=rules[i](state,line,endLine,!1));i++);state.tight=!hasEmptyLines;state.isEmpty(state.line-1)&&(hasEmptyLines=!0);line=state.line;line<endLine&&state.isEmpty(line)&&(hasEmptyLines=!0,line++,state.line=line)}};\nParserBlock.prototype.parse=function(src,md,env,outTokens){src&&(src=new this.State(src,md,env,outTokens),this.tokenize(src,src.line,src.lineMax))};ParserBlock.prototype.State=require(\"module$node_modules$markdown_it$lib$rules_block$state_block\");module.exports=ParserBlock}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$parser_block\"] = function(global,require,module,exports) {\n/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$markdown_it$lib$rules_block$heading","~$module$node_modules$markdown_it$lib$rules_block$html_block","~$module$node_modules$markdown_it$lib$rules_block$table","~$module$node_modules$markdown_it$lib$rules_block$reference","~$module$node_modules$markdown_it$lib$ruler","~$shadow.js","~$module$node_modules$markdown_it$lib$rules_block$paragraph","~$module$node_modules$markdown_it$lib$rules_block$hr","~$module$node_modules$markdown_it$lib$rules_block$lheading","~$module$node_modules$markdown_it$lib$rules_block$code","~$module$node_modules$markdown_it$lib$rules_block$list","~$module$node_modules$markdown_it$lib$rules_block$fence","~$module$node_modules$markdown_it$lib$rules_block$state_block","~$module$node_modules$markdown_it$lib$rules_block$blockquote"]],"~:properties",["^5",["tokenize","tight","alt","line","parse","State","ruler"]],"~:compiled-at",1591107371174,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$parser_block.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/parser_block.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$parser_block\\\"] = function(global,require,module,exports) {\\n/** internal\\n * class ParserBlock\\n *\\n * Block-level tokenizer.\\n **/\\n'use strict';\\n\\n\\nvar Ruler           = require('./ruler');\\n\\n\\nvar _rules = [\\n  // First 2 params - rule name & source. Secondary array - list of rules,\\n  // which can be terminated by this one.\\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\\n  [ 'code',       require('./rules_block/code') ],\\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\\n  [ 'reference',  require('./rules_block/reference') ],\\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\\n  [ 'lheading',   require('./rules_block/lheading') ],\\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\\n  [ 'paragraph',  require('./rules_block/paragraph') ]\\n];\\n\\n\\n/**\\n * new ParserBlock()\\n **/\\nfunction ParserBlock() {\\n  /**\\n   * ParserBlock#ruler -> Ruler\\n   *\\n   * [[Ruler]] instance. Keep configuration of block rules.\\n   **/\\n  this.ruler = new Ruler();\\n\\n  for (var i = 0; i < _rules.length; i++) {\\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\\n  }\\n}\\n\\n\\n// Generate tokens for input range\\n//\\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\\n  var ok, i,\\n      rules = this.ruler.getRules(''),\\n      len = rules.length,\\n      line = startLine,\\n      hasEmptyLines = false,\\n      maxNesting = state.md.options.maxNesting;\\n\\n  while (line < endLine) {\\n    state.line = line = state.skipEmptyLines(line);\\n    if (line >= endLine) { break; }\\n\\n    // Termination condition for nested calls.\\n    // Nested calls currently used for blockquotes & lists\\n    if (state.sCount[line] < state.blkIndent) { break; }\\n\\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\\n    // situation and we should not care about content.\\n    if (state.level >= maxNesting) {\\n      state.line = endLine;\\n      break;\\n    }\\n\\n    // Try all possible rules.\\n    // On success, rule should:\\n    //\\n    // - update `state.line`\\n    // - update `state.tokens`\\n    // - return true\\n\\n    for (i = 0; i < len; i++) {\\n      ok = rules[i](state, line, endLine, false);\\n      if (ok) { break; }\\n    }\\n\\n    // set state.tight if we had an empty line before current tag\\n    // i.e. latest empty line should not count\\n    state.tight = !hasEmptyLines;\\n\\n    // paragraph might \\\"eat\\\" one newline after it in nested lists\\n    if (state.isEmpty(state.line - 1)) {\\n      hasEmptyLines = true;\\n    }\\n\\n    line = state.line;\\n\\n    if (line < endLine && state.isEmpty(line)) {\\n      hasEmptyLines = true;\\n      line++;\\n      state.line = line;\\n    }\\n  }\\n};\\n\\n\\n/**\\n * ParserBlock.parse(str, md, env, outTokens)\\n *\\n * Process input string and push block tokens into `outTokens`\\n **/\\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\\n  var state;\\n\\n  if (!src) { return; }\\n\\n  state = new this.State(src, md, env, outTokens);\\n\\n  this.tokenize(state, state.line, state.lineMax);\\n};\\n\\n\\nParserBlock.prototype.State = require('./rules_block/state_block');\\n\\n\\nmodule.exports = ParserBlock;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"ParserBlock\",\"ruler\",\"Ruler\",\"i\",\"_rules\",\"length\",\"push\",\"alt\",\"slice\",\"prototype\",\"tokenize\",\"ParserBlock.prototype.tokenize\",\"state\",\"startLine\",\"endLine\",\"rules\",\"getRules\",\"len\",\"line\",\"hasEmptyLines\",\"maxNesting\",\"md\",\"options\",\"skipEmptyLines\",\"sCount\",\"blkIndent\",\"level\",\"ok\",\"tight\",\"isEmpty\",\"parse\",\"ParserBlock.prototype.parse\",\"src\",\"env\",\"outTokens\",\"State\",\"lineMax\"]\n}\n"]