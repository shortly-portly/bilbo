["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/helpers/parse_link_label.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$helpers$parse_link_label=function(global,require,module,exports){module.exports=function(state,start,disableNested){var labelEnd=-1,max=state.posMax,oldPos=state.pos;state.pos=start+1;for(start=1;state.pos<max;){var marker=state.src.charCodeAt(state.pos);if(93===marker&&(start--,0===start)){var found=!0;break}var prevPos=state.pos;state.md.inline.skipToken(state);if(91===marker)if(prevPos===state.pos-1)start++;else if(disableNested)return state.pos=\noldPos,-1}found&&(labelEnd=state.pos);state.pos=oldPos;return labelEnd}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$helpers$parse_link_label\"] = function(global,require,module,exports) {\n// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n'use strict';\n\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\n  var level, found, marker, prevPos,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos;\n\n  state.pos = start + 1;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n\n  return labelEnd;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["pos"]],"~:compiled-at",1591107371165,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$helpers$parse_link_label.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,6DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAQzHD,MAAAC,QAAA,CAAiBC,QAAuB,CAACC,KAAD,CAAQC,KAAR,CAAeC,aAAf,CAA8B,CAAA,IAEhEC,SAAW,EAFqD,CAGhEC,IAAMJ,KAAAK,OAH0D,CAIhEC,OAASN,KAAAO,IAEbP,MAAAO,IAAA,CAAYN,KAAZ,CAAoB,CAGpB,KAFAO,KAEA,CAFQ,CAER,CAAOR,KAAAO,IAAP,CAAmBH,GAAnB,CAAA,CAAwB,CACtB,IAAAK,OAAST,KAAAU,IAAAC,WAAA,CAAqBX,KAAAO,IAArB,CACT,IAAe,EAAf,GAAIE,MAAJ,GACED,KAAA,EACI,CAAU,CAAV,GAAAA,KAFN,EAEmB,CACf,IAAAI,MAAQ,CAAA,CACR,MAFe,CAMnB,IAAAC,QAAUb,KAAAO,IACVP,MAAAc,GAAAC,OAAAC,UAAA,CAA0BhB,KAA1B,CACA,IAAe,EAAf,GAAIS,MAAJ,CACE,GAAII,OAAJ,GAAgBb,KAAAO,IAAhB,CAA4B,CAA5B,CAEEC,KAAA,EAFF,KAGO,IAAIN,aAAJ,CAEL,MADAF,MAAAO,IACO;AADKD,MACL,CAAA,EAlBW,CAuBpBM,KAAJ,GACET,QADF,CACaH,KAAAO,IADb,CAKAP,MAAAO,IAAA,CAAYD,MAEZ,OAAOH,SAvC6D,CARmD;\",\n\"sources\":[\"node_modules/markdown-it/lib/helpers/parse_link_label.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$helpers$parse_link_label\\\"] = function(global,require,module,exports) {\\n// Parse link label\\n//\\n// this function assumes that first character (\\\"[\\\") already matches;\\n// returns the end of the label\\n//\\n'use strict';\\n\\nmodule.exports = function parseLinkLabel(state, start, disableNested) {\\n  var level, found, marker, prevPos,\\n      labelEnd = -1,\\n      max = state.posMax,\\n      oldPos = state.pos;\\n\\n  state.pos = start + 1;\\n  level = 1;\\n\\n  while (state.pos < max) {\\n    marker = state.src.charCodeAt(state.pos);\\n    if (marker === 0x5D /* ] */) {\\n      level--;\\n      if (level === 0) {\\n        found = true;\\n        break;\\n      }\\n    }\\n\\n    prevPos = state.pos;\\n    state.md.inline.skipToken(state);\\n    if (marker === 0x5B /* [ */) {\\n      if (prevPos === state.pos - 1) {\\n        // increase level if we find text `[`, which is not a part of any token\\n        level++;\\n      } else if (disableNested) {\\n        state.pos = oldPos;\\n        return -1;\\n      }\\n    }\\n  }\\n\\n  if (found) {\\n    labelEnd = state.pos;\\n  }\\n\\n  // restore old state\\n  state.pos = oldPos;\\n\\n  return labelEnd;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"module.exports\",\"state\",\"start\",\"disableNested\",\"labelEnd\",\"max\",\"posMax\",\"oldPos\",\"pos\",\"level\",\"marker\",\"src\",\"charCodeAt\",\"found\",\"prevPos\",\"md\",\"inline\",\"skipToken\"]\n}\n"]