["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_block/html_block.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_block$html_block=function(global,require,module,exports){global=require(\"module$node_modules$markdown_it$lib$common$html_blocks\");require=require(\"module$node_modules$markdown_it$lib$common$html_re\").HTML_OPEN_CLOSE_TAG_RE;var HTML_SEQUENCES=[[/^<(script|pre|style)(?=(\\s|>|$))/i,/<\\/(script|pre|style)>/i,!0],[/^\\x3c!--/,/--\\x3e/,!0],[/^<\\?/,/\\?>/,!0],[/^<![A-Z]/,/>/,!0],[/^<!\\[CDATA\\[/,/\\]\\]>/,!0],[new RegExp(\"^\\x3c/?(\"+global.join(\"|\")+\")(?\\x3d(\\\\s|/?\\x3e|$))\",\n\"i\"),/^$/,!0],[new RegExp(require.source+\"\\\\s*$\"),/^$/,!1]];module.exports=function(state,startLine,endLine,silent){var i;var lineText=state.bMarks[startLine]+state.tShift[startLine];var max=state.eMarks[startLine];if(4<=state.sCount[startLine]-state.blkIndent||!state.md.options.html||60!==state.src.charCodeAt(lineText))return!1;lineText=state.src.slice(lineText,max);for(i=0;i<HTML_SEQUENCES.length&&!HTML_SEQUENCES[i][0].test(lineText);i++);if(i===HTML_SEQUENCES.length)return!1;if(silent)return HTML_SEQUENCES[i][2];\nsilent=startLine+1;if(!HTML_SEQUENCES[i][1].test(lineText))for(;silent<endLine&&!(state.sCount[silent]<state.blkIndent);silent++)if(lineText=state.bMarks[silent]+state.tShift[silent],max=state.eMarks[silent],lineText=state.src.slice(lineText,max),HTML_SEQUENCES[i][1].test(lineText)){0!==lineText.length&&silent++;break}state.line=silent;endLine=state.push(\"html_block\",\"\",0);endLine.map=[startLine,silent];endLine.content=state.getLines(startLine,silent,state.blkIndent,!0);return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$html_block\"] = function(global,require,module,exports) {\n// HTML block\n\n'use strict';\n\n\nvar block_names = require('../common/html_blocks');\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nvar HTML_SEQUENCES = [\n  [ /^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true ],\n  [ /^<!--/,        /-->/,   true ],\n  [ /^<\\?/,         /\\?>/,   true ],\n  [ /^<![A-Z]/,     />/,     true ],\n  [ /^<!\\[CDATA\\[/, /\\]\\]>/, true ],\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true ],\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false ]\n];\n\n\nmodule.exports = function html_block(state, startLine, endLine, silent) {\n  var i, nextLine, token, lineText,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (!state.md.options.html) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\n\n  lineText = state.src.slice(pos, max);\n\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\n  }\n\n  if (i === HTML_SEQUENCES.length) { return false; }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n\n  nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++; }\n        break;\n      }\n    }\n  }\n\n  state.line = nextLine;\n\n  token         = state.push('html_block', '', 0);\n  token.map     = [ startLine, nextLine ];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$markdown_it$lib$common$html_re","~$shadow.js","~$module$node_modules$markdown_it$lib$common$html_blocks"]],"~:properties",["^5",["map","content","line"]],"~:compiled-at",1591107371173,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_block$html_block.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_block/html_block.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_block$html_block\\\"] = function(global,require,module,exports) {\\n// HTML block\\n\\n'use strict';\\n\\n\\nvar block_names = require('../common/html_blocks');\\nvar HTML_OPEN_CLOSE_TAG_RE = require('../common/html_re').HTML_OPEN_CLOSE_TAG_RE;\\n\\n// An array of opening and corresponding closing sequences for html tags,\\n// last argument defines whether it can terminate a paragraph or not\\n//\\nvar HTML_SEQUENCES = [\\n  [ /^<(script|pre|style)(?=(\\\\s|>|$))/i, /<\\\\/(script|pre|style)>/i, true ],\\n  [ /^\\u003c!--/,        /--\\u003e/,   true ],\\n  [ /^<\\\\?/,         /\\\\?>/,   true ],\\n  [ /^<![A-Z]/,     />/,     true ],\\n  [ /^<!\\\\[CDATA\\\\[/, /\\\\]\\\\]>/, true ],\\n  [ new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\\\\\s|/?>|$))', 'i'), /^$/, true ],\\n  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\\\\\s*$'),  /^$/, false ]\\n];\\n\\n\\nmodule.exports = function html_block(state, startLine, endLine, silent) {\\n  var i, nextLine, token, lineText,\\n      pos = state.bMarks[startLine] + state.tShift[startLine],\\n      max = state.eMarks[startLine];\\n\\n  // if it's indented more than 3 spaces, it should be a code block\\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\\n\\n  if (!state.md.options.html) { return false; }\\n\\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }\\n\\n  lineText = state.src.slice(pos, max);\\n\\n  for (i = 0; i < HTML_SEQUENCES.length; i++) {\\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }\\n  }\\n\\n  if (i === HTML_SEQUENCES.length) { return false; }\\n\\n  if (silent) {\\n    // true if this sequence can be a terminator, false otherwise\\n    return HTML_SEQUENCES[i][2];\\n  }\\n\\n  nextLine = startLine + 1;\\n\\n  // If we are here - we detected HTML block.\\n  // Let's roll down till block end.\\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\\n    for (; nextLine < endLine; nextLine++) {\\n      if (state.sCount[nextLine] < state.blkIndent) { break; }\\n\\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\\n      max = state.eMarks[nextLine];\\n      lineText = state.src.slice(pos, max);\\n\\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\\n        if (lineText.length !== 0) { nextLine++; }\\n        break;\\n      }\\n    }\\n  }\\n\\n  state.line = nextLine;\\n\\n  token         = state.push('html_block', '', 0);\\n  token.map     = [ startLine, nextLine ];\\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\\n\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"block_names\",\"HTML_OPEN_CLOSE_TAG_RE\",\"HTML_SEQUENCES\",\"RegExp\",\"join\",\"source\",\"module.exports\",\"state\",\"startLine\",\"endLine\",\"silent\",\"i\",\"pos\",\"bMarks\",\"tShift\",\"max\",\"eMarks\",\"sCount\",\"blkIndent\",\"md\",\"options\",\"html\",\"src\",\"charCodeAt\",\"lineText\",\"slice\",\"length\",\"test\",\"nextLine\",\"line\",\"token\",\"push\",\"map\",\"content\",\"getLines\"]\n}\n"]