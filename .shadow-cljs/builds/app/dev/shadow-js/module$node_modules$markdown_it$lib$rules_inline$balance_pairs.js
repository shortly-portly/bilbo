["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_inline/balance_pairs.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_inline$balance_pairs=function(global,require,module,exports){function processDelimiters(state,delimiters){var openerIdx,openersBottom={},max=delimiters.length;for(state=0;state<max;state++){var closer=delimiters[state];closer.length=closer.length||0;if(closer.close){openersBottom.hasOwnProperty(closer.marker)||(openersBottom[closer.marker]=[-1,-1,-1]);var minOpenerIdx=openersBottom[closer.marker][closer.length%3];var newMinOpenerIdx=-1;for(openerIdx=\nstate-closer.jump-1;openerIdx>minOpenerIdx;openerIdx-=opener.jump+1){var opener=delimiters[openerIdx];if(opener.marker===closer.marker&&(-1===newMinOpenerIdx&&(newMinOpenerIdx=openerIdx),opener.open&&0>opener.end&&opener.level===closer.level)){var isOddMatch=!1;!opener.close&&!closer.open||0!==(opener.length+closer.length)%3||0===opener.length%3&&0===closer.length%3||(isOddMatch=!0);if(!isOddMatch){minOpenerIdx=0<openerIdx&&!delimiters[openerIdx-1].open?delimiters[openerIdx-1].jump+1:0;closer.jump=\nstate-openerIdx+minOpenerIdx;closer.open=!1;opener.end=state;opener.jump=minOpenerIdx;opener.close=!1;newMinOpenerIdx=-1;break}}}-1!==newMinOpenerIdx&&(openersBottom[closer.marker][(closer.length||0)%3]=newMinOpenerIdx)}}}module.exports=function(state){var curr,tokens_meta=state.tokens_meta,max=state.tokens_meta.length;processDelimiters(state,state.delimiters);for(curr=0;curr<max;curr++)tokens_meta[curr]&&tokens_meta[curr].delimiters&&processDelimiters(state,tokens_meta[curr].delimiters)}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$balance_pairs\"] = function(global,require,module,exports) {\n// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker and each delimiter length modulo 3.\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\n    newMinOpenerIdx = -1;\n\n    openerIdx = closerIdx - closer.jump - 1;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\n\n      if (opener.open &&\n          opener.end < 0 &&\n          opener.level === closer.level) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            delimiters[openerIdx - 1].jump + 1 :\n            0;\n\n          closer.jump  = closerIdx - openerIdx + lastJump;\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.jump  = lastJump;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["jump","length","close","open","end"]],"~:compiled-at",1591107371178,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_inline$balance_pairs.js\",\n\"lineCount\":3,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_inline/balance_pairs.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_inline$balance_pairs\\\"] = function(global,require,module,exports) {\\n// For each opening emphasis-like marker find a matching closing one\\n//\\n'use strict';\\n\\n\\nfunction processDelimiters(state, delimiters) {\\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\\n      isOddMatch, lastJump,\\n      openersBottom = {},\\n      max = delimiters.length;\\n\\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\\n    closer = delimiters[closerIdx];\\n\\n    // Length is only used for emphasis-specific \\\"rule of 3\\\",\\n    // if it's not defined (in strikethrough or 3rd party plugins),\\n    // we can default it to 0 to disable those checks.\\n    //\\n    closer.length = closer.length || 0;\\n\\n    if (!closer.close) continue;\\n\\n    // Previously calculated lower bounds (previous fails)\\n    // for each marker and each delimiter length modulo 3.\\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\\n      openersBottom[closer.marker] = [ -1, -1, -1 ];\\n    }\\n\\n    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];\\n    newMinOpenerIdx = -1;\\n\\n    openerIdx = closerIdx - closer.jump - 1;\\n\\n    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {\\n      opener = delimiters[openerIdx];\\n\\n      if (opener.marker !== closer.marker) continue;\\n\\n      if (newMinOpenerIdx === -1) newMinOpenerIdx = openerIdx;\\n\\n      if (opener.open &&\\n          opener.end < 0 &&\\n          opener.level === closer.level) {\\n\\n        isOddMatch = false;\\n\\n        // from spec:\\n        //\\n        // If one of the delimiters can both open and close emphasis, then the\\n        // sum of the lengths of the delimiter runs containing the opening and\\n        // closing delimiters must not be a multiple of 3 unless both lengths\\n        // are multiples of 3.\\n        //\\n        if (opener.close || closer.open) {\\n          if ((opener.length + closer.length) % 3 === 0) {\\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\\n              isOddMatch = true;\\n            }\\n          }\\n        }\\n\\n        if (!isOddMatch) {\\n          // If previous delimiter cannot be an opener, we can safely skip\\n          // the entire sequence in future checks. This is required to make\\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\\n          //\\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\\n            delimiters[openerIdx - 1].jump + 1 :\\n            0;\\n\\n          closer.jump  = closerIdx - openerIdx + lastJump;\\n          closer.open  = false;\\n          opener.end   = closerIdx;\\n          opener.jump  = lastJump;\\n          opener.close = false;\\n          newMinOpenerIdx = -1;\\n          break;\\n        }\\n      }\\n    }\\n\\n    if (newMinOpenerIdx !== -1) {\\n      // If match for this delimiter run failed, we want to set lower bound for\\n      // future lookups. This is required to make sure algorithm has linear\\n      // complexity.\\n      //\\n      // See details here:\\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\\n      //\\n      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;\\n    }\\n  }\\n}\\n\\n\\nmodule.exports = function link_pairs(state) {\\n  var curr,\\n      tokens_meta = state.tokens_meta,\\n      max = state.tokens_meta.length;\\n\\n  processDelimiters(state, state.delimiters);\\n\\n  for (curr = 0; curr < max; curr++) {\\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\\n      processDelimiters(state, tokens_meta[curr].delimiters);\\n    }\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"processDelimiters\",\"state\",\"delimiters\",\"openerIdx\",\"openersBottom\",\"max\",\"length\",\"closerIdx\",\"closer\",\"close\",\"hasOwnProperty\",\"marker\",\"minOpenerIdx\",\"newMinOpenerIdx\",\"jump\",\"opener\",\"open\",\"end\",\"level\",\"isOddMatch\",\"lastJump\",\"module.exports\",\"curr\",\"tokens_meta\"]\n}\n"]