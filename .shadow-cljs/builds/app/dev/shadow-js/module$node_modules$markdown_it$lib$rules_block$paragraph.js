["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_block/paragraph.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_block$paragraph=function(global,require,module,exports){module.exports=function(state,startLine){var l;var token=startLine+1;var terminatorRules=state.md.block.ruler.getRules(\"paragraph\"),endLine=state.lineMax;var oldParentType=state.parentType;for(state.parentType=\"paragraph\";token<endLine&&!state.isEmpty(token);token++)if(!(3<state.sCount[token]-state.blkIndent||0>state.sCount[token])){var content=!1;var i=0;for(l=terminatorRules.length;i<\nl;i++)if(terminatorRules[i](state,token,endLine,!0)){content=!0;break}if(content)break}content=state.getLines(startLine,token,state.blkIndent,!1).trim();state.line=token;token=state.push(\"paragraph_open\",\"p\",1);token.map=[startLine,state.line];token=state.push(\"inline\",\"\",0);token.content=content;token.map=[startLine,state.line];token.children=[];state.push(\"paragraph_close\",\"p\",-1);state.parentType=oldParentType;return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$paragraph\"] = function(global,require,module,exports) {\n// Paragraph\n\n'use strict';\n\n\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\n  var content, terminate, i, l, token, oldParentType,\n      nextLine = startLine + 1,\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\n      endLine = state.lineMax;\n\n  oldParentType = state.parentType;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n\n  state.line = nextLine;\n\n  token          = state.push('paragraph_open', 'p', 1);\n  token.map      = [ startLine, state.line ];\n\n  token          = state.push('inline', '', 0);\n  token.content  = content;\n  token.map      = [ startLine, state.line ];\n  token.children = [];\n\n  token          = state.push('paragraph_close', 'p', -1);\n\n  state.parentType = oldParentType;\n\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["map","children","content","line","parentType"]],"~:compiled-at",1591107371174,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_block$paragraph.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,0DAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAMtHD,MAAAC,QAAA,CAAiBC,QAAkB,CAACC,KAAD,CAAQC,SAAR,CAAgC,CAAA,IACtCC,CACvBC,KAAAA,MAAWF,SAAXE,CAAuB,CAFsC,KAG7DC,gBAAkBJ,KAAAK,GAAAC,MAAAC,MAAAC,SAAA,CAA8B,WAA9B,CAH2C,CAI7DC,QAAUT,KAAAU,QAEd,KAAAC,cAAgBX,KAAAY,WAIhB,KAHAZ,KAAAY,WAGA,CAHmB,WAGnB,CAAOT,KAAP,CAAkBM,OAAlB,EAA6B,CAACT,KAAAa,QAAA,CAAcV,KAAd,CAA9B,CAAuDA,KAAA,EAAvD,CAGE,GAAI,EAA2C,CAA3C,CAAAH,KAAAc,OAAA,CAAaX,KAAb,CAAA,CAAyBH,KAAAe,UAAzB,EAGyB,CAHzB,CAGAf,KAAAc,OAAA,CAAaX,KAAb,CAHA,CAAJ,CAGA,CAGA,IAAAa,QAAY,CAAA,CACP,KAAAC,EAAI,CAAT,KAAYf,CAAZ,CAAgBE,eAAAc,OAAhB,CAAwCD,CAAxC;AAA4Cf,CAA5C,CAA+Ce,CAAA,EAA/C,CACE,GAAIb,eAAA,CAAgBa,CAAhB,CAAA,CAAmBjB,KAAnB,CAA0BG,KAA1B,CAAoCM,OAApC,CAA6C,CAAA,CAA7C,CAAJ,CAAwD,CACtDO,OAAA,CAAY,CAAA,CACZ,MAFsD,CAK1D,GAAIA,OAAJ,CAAiB,KAVjB,CAaFG,OAAA,CAAUnB,KAAAoB,SAAA,CAAenB,SAAf,CAA0BE,KAA1B,CAAoCH,KAAAe,UAApC,CAAqD,CAAA,CAArD,CAAAM,KAAA,EAEVrB,MAAAsB,KAAA,CAAanB,KAEboB,MAAA,CAAiBvB,KAAAwB,KAAA,CAAW,gBAAX,CAA6B,GAA7B,CAAkC,CAAlC,CACjBD,MAAAE,IAAA,CAAiB,CAAExB,SAAF,CAAaD,KAAAsB,KAAb,CAEjBC,MAAA,CAAiBvB,KAAAwB,KAAA,CAAW,QAAX,CAAqB,EAArB,CAAyB,CAAzB,CACjBD,MAAAJ,QAAA,CAAiBA,OACjBI,MAAAE,IAAA,CAAiB,CAAExB,SAAF,CAAaD,KAAAsB,KAAb,CACjBC,MAAAG,SAAA,CAAiB,EAEA1B,MAAAwB,KAAA,CAAW,iBAAX,CAA8B,GAA9B,CAAmC,EAAnC,CAEjBxB,MAAAY,WAAA,CAAmBD,aAEnB,OAAO,CAAA,CA7C0D,CANmD;\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_block/paragraph.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_block$paragraph\\\"] = function(global,require,module,exports) {\\n// Paragraph\\n\\n'use strict';\\n\\n\\nmodule.exports = function paragraph(state, startLine/*, endLine*/) {\\n  var content, terminate, i, l, token, oldParentType,\\n      nextLine = startLine + 1,\\n      terminatorRules = state.md.block.ruler.getRules('paragraph'),\\n      endLine = state.lineMax;\\n\\n  oldParentType = state.parentType;\\n  state.parentType = 'paragraph';\\n\\n  // jump line-by-line until empty one or EOF\\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\\n    // this would be a code block normally, but after paragraph\\n    // it's considered a lazy continuation regardless of what's there\\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\\n\\n    // quirk for blockquotes, this line should already be checked by that rule\\n    if (state.sCount[nextLine] < 0) { continue; }\\n\\n    // Some tags can terminate paragraph without empty line.\\n    terminate = false;\\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\\n        terminate = true;\\n        break;\\n      }\\n    }\\n    if (terminate) { break; }\\n  }\\n\\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\\n\\n  state.line = nextLine;\\n\\n  token          = state.push('paragraph_open', 'p', 1);\\n  token.map      = [ startLine, state.line ];\\n\\n  token          = state.push('inline', '', 0);\\n  token.content  = content;\\n  token.map      = [ startLine, state.line ];\\n  token.children = [];\\n\\n  token          = state.push('paragraph_close', 'p', -1);\\n\\n  state.parentType = oldParentType;\\n\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"module.exports\",\"state\",\"startLine\",\"l\",\"nextLine\",\"terminatorRules\",\"md\",\"block\",\"ruler\",\"getRules\",\"endLine\",\"lineMax\",\"oldParentType\",\"parentType\",\"isEmpty\",\"sCount\",\"blkIndent\",\"terminate\",\"i\",\"length\",\"content\",\"getLines\",\"trim\",\"line\",\"token\",\"push\",\"map\",\"children\"]\n}\n"]