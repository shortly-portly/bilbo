["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_inline/backticks.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_inline$backticks=function(global,require,module,exports){module.exports=function(state,silent){var max,matchStart,matchEnd,pos=state.pos;if(96!==state.src.charCodeAt(pos))return!1;var start=pos;pos++;for(max=state.posMax;pos<max&&96===state.src.charCodeAt(pos);)pos++;start=state.src.slice(start,pos);for(matchEnd=pos;-1!==(matchStart=state.src.indexOf(\"`\",matchEnd));){for(matchEnd=matchStart+1;matchEnd<max&&96===state.src.charCodeAt(matchEnd);)matchEnd++;\nif(matchEnd-matchStart===start.length)return silent||(silent=state.push(\"code_inline\",\"code\",0),silent.markup=start,silent.content=state.src.slice(pos,matchStart).replace(/\\n/g,\" \").replace(/^ (.+) $/,\"$1\")),state.pos=matchEnd,!0}silent||(state.pending+=start);state.pos+=start.length;return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$backticks\"] = function(global,require,module,exports) {\n// Parse backticks\n\n'use strict';\n\nmodule.exports = function backtick(state, silent) {\n  var start, max, marker, matchStart, matchEnd, token,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60/* ` */) { return false; }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\n\n  marker = state.src.slice(start, pos);\n\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        token         = state.push('code_inline', 'code', 0);\n        token.markup  = marker;\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1');\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += marker; }\n  state.pos += marker.length;\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["pos","markup","content","pending"]],"~:compiled-at",1591107371175,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_inline$backticks.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,2DAAA,CAA+E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAKvHD,MAAAC,QAAA,CAAiBC,QAAiB,CAACC,KAAD,CAAQC,MAAR,CAAgB,CAAA,IACrCC,GADqC,CACxBC,UADwB,CACZC,QADY,CAE5CC,IAAML,KAAAK,IAGV,IAAW,EAAX,GAFSL,KAAAM,IAAAC,WAAAC,CAAqBH,GAArBG,CAET,CAA0B,MAAO,CAAA,CAEjC,KAAAC,MAAQJ,GACRA,IAAA,EAGA,KAFAH,GAEA,CAFMF,KAAAU,OAEN,CAAOL,GAAP,CAAaH,GAAb,EAAkD,EAAlD,GAAoBF,KAAAM,IAAAC,WAAA,CAAqBF,GAArB,CAApB,CAAA,CAAiEA,GAAA,EAEjEM,MAAA,CAASX,KAAAM,IAAAM,MAAA,CAAgBH,KAAhB,CAAuBJ,GAAvB,CAIT,KAFaD,QAEb,CAFwBC,GAExB,CAA2D,EAA3D,IAAQF,UAAR,CAAqBH,KAAAM,IAAAO,QAAA,CAAkB,GAAlB,CAAuBT,QAAvB,CAArB,EAAA,CAA+D,CAG7D,IAFAA,QAEA,CAFWD,UAEX,CAFwB,CAExB,CAAOC,QAAP,CAAkBF,GAAlB,EAA4D,EAA5D,GAAyBF,KAAAM,IAAAC,WAAA,CAAqBH,QAArB,CAAzB,CAAA,CAA2EA,QAAA,EAE3E;GAAIA,QAAJ,CAAeD,UAAf,GAA8BQ,KAAAG,OAA9B,CASE,MARKb,OAQE,GAPLc,MAEA,CAFgBf,KAAAgB,KAAA,CAAW,aAAX,CAA0B,MAA1B,CAAkC,CAAlC,CAEhB,CADAD,MAAAE,OACA,CADgBN,KAChB,CAAAI,MAAAG,QAAA,CAAgBlB,KAAAM,IAAAM,MAAA,CAAgBP,GAAhB,CAAqBF,UAArB,CAAAgB,QAAA,CACL,KADK,CACE,GADF,CAAAA,QAAA,CAEL,UAFK,CAEO,IAFP,CAKX,EADPnB,KAAAK,IACO,CADKD,QACL,CAAA,CAAA,CAdoD,CAkB1DH,MAAL,GAAeD,KAAAoB,QAAf,EAAgCT,KAAhC,CACAX,MAAAK,IAAA,EAAaM,KAAAG,OACb,OAAO,CAAA,CArCyC,CALqE;\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_inline/backticks.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_inline$backticks\\\"] = function(global,require,module,exports) {\\n// Parse backticks\\n\\n'use strict';\\n\\nmodule.exports = function backtick(state, silent) {\\n  var start, max, marker, matchStart, matchEnd, token,\\n      pos = state.pos,\\n      ch = state.src.charCodeAt(pos);\\n\\n  if (ch !== 0x60/* ` */) { return false; }\\n\\n  start = pos;\\n  pos++;\\n  max = state.posMax;\\n\\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }\\n\\n  marker = state.src.slice(start, pos);\\n\\n  matchStart = matchEnd = pos;\\n\\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\\n    matchEnd = matchStart + 1;\\n\\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }\\n\\n    if (matchEnd - matchStart === marker.length) {\\n      if (!silent) {\\n        token         = state.push('code_inline', 'code', 0);\\n        token.markup  = marker;\\n        token.content = state.src.slice(pos, matchStart)\\n          .replace(/\\\\n/g, ' ')\\n          .replace(/^ (.+) $/, '$1');\\n      }\\n      state.pos = matchEnd;\\n      return true;\\n    }\\n  }\\n\\n  if (!silent) { state.pending += marker; }\\n  state.pos += marker.length;\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"module.exports\",\"state\",\"silent\",\"max\",\"matchStart\",\"matchEnd\",\"pos\",\"src\",\"charCodeAt\",\"ch\",\"start\",\"posMax\",\"marker\",\"slice\",\"indexOf\",\"length\",\"token\",\"push\",\"markup\",\"content\",\"replace\",\"pending\"]\n}\n"]