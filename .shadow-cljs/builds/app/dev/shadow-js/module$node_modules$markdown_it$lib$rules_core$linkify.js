["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_core/linkify.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_core$linkify=function(global,require,module,exports){var arrayReplaceAt=require(\"module$node_modules$markdown_it$lib$common$utils\").arrayReplaceAt;module.exports=function(state){var i,l,lastPos,blockTokens=state.tokens;if(state.md.options.linkify){var j=0;for(l=blockTokens.length;j<l;j++)if(\"inline\"===blockTokens[j].type&&state.md.linkify.pretest(blockTokens[j].content)){var tokens=blockTokens[j].children;var htmlLinkLevel=0;for(i=tokens.length-\n1;0<=i;i--){var currentToken=tokens[i];if(\"link_close\"===currentToken.type)for(i--;tokens[i].level!==currentToken.level&&\"link_open\"!==tokens[i].type;)i--;else if(\"html_inline\"===currentToken.type&&(/^<a[>\\s]/i.test(currentToken.content)&&0<htmlLinkLevel&&htmlLinkLevel--,/^<\\/a\\s*>/i.test(currentToken.content)&&htmlLinkLevel++),!(0<htmlLinkLevel)&&\"text\"===currentToken.type&&state.md.linkify.test(currentToken.content)){var text=currentToken.content;var links=state.md.linkify.match(text);var nodes=\n[];var level=currentToken.level;for(currentToken=lastPos=0;currentToken<links.length;currentToken++){var token=links[currentToken].url;var fullUrl=state.md.normalizeLink(token);if(state.md.validateLink(fullUrl)){var urlText=links[currentToken].text;urlText=links[currentToken].schema?\"mailto:\"!==links[currentToken].schema||/^mailto:/i.test(urlText)?state.md.normalizeLinkText(urlText):state.md.normalizeLinkText(\"mailto:\"+urlText).replace(/^mailto:/,\"\"):state.md.normalizeLinkText(\"http://\"+urlText).replace(/^http:\\/\\//,\n\"\");var pos=links[currentToken].index;pos>lastPos&&(token=new state.Token(\"text\",\"\",0),token.content=text.slice(lastPos,pos),token.level=level,nodes.push(token));token=new state.Token(\"link_open\",\"a\",1);token.attrs=[[\"href\",fullUrl]];token.level=level++;token.markup=\"linkify\";token.info=\"auto\";nodes.push(token);token=new state.Token(\"text\",\"\",0);token.content=urlText;token.level=level;nodes.push(token);token=new state.Token(\"link_close\",\"a\",-1);token.level=--level;token.markup=\"linkify\";token.info=\n\"auto\";nodes.push(token);lastPos=links[currentToken].lastIndex}}lastPos<text.length&&(token=new state.Token(\"text\",\"\",0),token.content=text.slice(lastPos),token.level=level,nodes.push(token));blockTokens[j].children=tokens=arrayReplaceAt(tokens,i,nodes)}}}}}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_core$linkify\"] = function(global,require,module,exports) {\n// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n'use strict';\n\n\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\n\n\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\n\n\nmodule.exports = function linkify(state) {\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\n      level, htmlLinkLevel, url, fullUrl, urlText,\n      blockTokens = state.tokens,\n      links;\n\n  if (!state.md.options.linkify) { return; }\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n\n    tokens = blockTokens[j].children;\n\n    htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (i = tokens.length - 1; i >= 0; i--) {\n      currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) { continue; }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n\n        text = currentToken.content;\n        links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        nodes = [];\n        level = currentToken.level;\n        lastPos = 0;\n\n        for (ln = 0; ln < links.length; ln++) {\n\n          url = links[ln].url;\n          fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) { continue; }\n\n          urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n\n          pos = links[ln].index;\n\n          if (pos > lastPos) {\n            token         = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level   = level;\n            nodes.push(token);\n          }\n\n          token         = new state.Token('link_open', 'a', 1);\n          token.attrs   = [ [ 'href', fullUrl ] ];\n          token.level   = level++;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          token         = new state.Token('text', '', 0);\n          token.content = urlText;\n          token.level   = level;\n          nodes.push(token);\n\n          token         = new state.Token('link_close', 'a', -1);\n          token.level   = --level;\n          token.markup  = 'linkify';\n          token.info    = 'auto';\n          nodes.push(token);\n\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          token         = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level   = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$markdown_it$lib$common$utils"]],"~:properties",["^5",["attrs","markup","children","info","level","content"]],"~:compiled-at",1591107371168,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_core$linkify.js\",\n\"lineCount\":5,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_core/linkify.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_core$linkify\\\"] = function(global,require,module,exports) {\\n// Replace link-like texts with link nodes.\\n//\\n// Currently restricted by `md.validateLink()` to http/https/ftp\\n//\\n'use strict';\\n\\n\\nvar arrayReplaceAt = require('../common/utils').arrayReplaceAt;\\n\\n\\nfunction isLinkOpen(str) {\\n  return /^<a[>\\\\s]/i.test(str);\\n}\\nfunction isLinkClose(str) {\\n  return /^<\\\\/a\\\\s*>/i.test(str);\\n}\\n\\n\\nmodule.exports = function linkify(state) {\\n  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,\\n      level, htmlLinkLevel, url, fullUrl, urlText,\\n      blockTokens = state.tokens,\\n      links;\\n\\n  if (!state.md.options.linkify) { return; }\\n\\n  for (j = 0, l = blockTokens.length; j < l; j++) {\\n    if (blockTokens[j].type !== 'inline' ||\\n        !state.md.linkify.pretest(blockTokens[j].content)) {\\n      continue;\\n    }\\n\\n    tokens = blockTokens[j].children;\\n\\n    htmlLinkLevel = 0;\\n\\n    // We scan from the end, to keep position when new tags added.\\n    // Use reversed logic in links start/end match\\n    for (i = tokens.length - 1; i >= 0; i--) {\\n      currentToken = tokens[i];\\n\\n      // Skip content of markdown links\\n      if (currentToken.type === 'link_close') {\\n        i--;\\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\\n          i--;\\n        }\\n        continue;\\n      }\\n\\n      // Skip content of html tag links\\n      if (currentToken.type === 'html_inline') {\\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\\n          htmlLinkLevel--;\\n        }\\n        if (isLinkClose(currentToken.content)) {\\n          htmlLinkLevel++;\\n        }\\n      }\\n      if (htmlLinkLevel > 0) { continue; }\\n\\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\\n\\n        text = currentToken.content;\\n        links = state.md.linkify.match(text);\\n\\n        // Now split string to nodes\\n        nodes = [];\\n        level = currentToken.level;\\n        lastPos = 0;\\n\\n        for (ln = 0; ln < links.length; ln++) {\\n\\n          url = links[ln].url;\\n          fullUrl = state.md.normalizeLink(url);\\n          if (!state.md.validateLink(fullUrl)) { continue; }\\n\\n          urlText = links[ln].text;\\n\\n          // Linkifier might send raw hostnames like \\\"example.com\\\", where url\\n          // starts with domain name. So we prepend http:// in those cases,\\n          // and remove it afterwards.\\n          //\\n          if (!links[ln].schema) {\\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\\\/\\\\//, '');\\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\\n          } else {\\n            urlText = state.md.normalizeLinkText(urlText);\\n          }\\n\\n          pos = links[ln].index;\\n\\n          if (pos > lastPos) {\\n            token         = new state.Token('text', '', 0);\\n            token.content = text.slice(lastPos, pos);\\n            token.level   = level;\\n            nodes.push(token);\\n          }\\n\\n          token         = new state.Token('link_open', 'a', 1);\\n          token.attrs   = [ [ 'href', fullUrl ] ];\\n          token.level   = level++;\\n          token.markup  = 'linkify';\\n          token.info    = 'auto';\\n          nodes.push(token);\\n\\n          token         = new state.Token('text', '', 0);\\n          token.content = urlText;\\n          token.level   = level;\\n          nodes.push(token);\\n\\n          token         = new state.Token('link_close', 'a', -1);\\n          token.level   = --level;\\n          token.markup  = 'linkify';\\n          token.info    = 'auto';\\n          nodes.push(token);\\n\\n          lastPos = links[ln].lastIndex;\\n        }\\n        if (lastPos < text.length) {\\n          token         = new state.Token('text', '', 0);\\n          token.content = text.slice(lastPos);\\n          token.level   = level;\\n          nodes.push(token);\\n        }\\n\\n        // replace current node\\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\\n      }\\n    }\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"arrayReplaceAt\",\"module.exports\",\"state\",\"i\",\"l\",\"lastPos\",\"blockTokens\",\"tokens\",\"md\",\"options\",\"linkify\",\"j\",\"length\",\"type\",\"pretest\",\"content\",\"children\",\"htmlLinkLevel\",\"currentToken\",\"level\",\"test\",\"text\",\"links\",\"match\",\"nodes\",\"ln\",\"url\",\"fullUrl\",\"normalizeLink\",\"validateLink\",\"urlText\",\"schema\",\"normalizeLinkText\",\"replace\",\"pos\",\"index\",\"token\",\"Token\",\"slice\",\"push\",\"attrs\",\"markup\",\"info\",\"lastIndex\"]\n}\n"]