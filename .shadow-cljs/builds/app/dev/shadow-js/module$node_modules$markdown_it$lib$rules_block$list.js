["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_block/list.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_block$list=function(global,require,module,exports){function skipBulletListMarker(state,startLine){var pos=state.bMarks[startLine]+state.tShift[startLine];var max=state.eMarks[startLine];startLine=state.src.charCodeAt(pos++);return 42!==startLine&&45!==startLine&&43!==startLine||pos<max&&(state=state.src.charCodeAt(pos),!isSpace(state))?-1:pos}function skipOrderedListMarker(state,startLine){var start=state.bMarks[startLine]+state.tShift[startLine],\npos=start,max=state.eMarks[startLine];if(pos+1>=max)return-1;startLine=state.src.charCodeAt(pos++);if(48>startLine||57<startLine)return-1;for(;;){if(pos>=max)return-1;startLine=state.src.charCodeAt(pos++);if(48<=startLine&&57>=startLine){if(10<=pos-start)return-1}else{if(41===startLine||46===startLine)break;return-1}}return pos<max&&(startLine=state.src.charCodeAt(pos),!isSpace(startLine))?-1:pos}var isSpace=require(\"module$node_modules$markdown_it$lib$common$utils\").isSpace;module.exports=function(state,\nstartLine,endLine,silent){var initial,l;var markerCharCode=!1;var tight=!0;if(4<=state.sCount[startLine]-state.blkIndent||0<=state.listIndent&&4<=state.sCount[startLine]-state.listIndent&&state.sCount[startLine]<state.blkIndent)return!1;silent&&\"paragraph\"===state.parentType&&state.tShift[startLine]>=state.blkIndent&&(markerCharCode=!0);if(0<=(l=skipOrderedListMarker(state,startLine))){var isOrdered=!0;var listLines=state.bMarks[startLine]+state.tShift[startLine];listLines=Number(state.src.substr(listLines,\nl-listLines-1));if(markerCharCode&&1!==listLines)return!1}else if(0<=(l=skipBulletListMarker(state,startLine)))isOrdered=!1;else return!1;if(markerCharCode&&state.skipSpaces(l)>=state.eMarks[startLine])return!1;markerCharCode=state.src.charCodeAt(l-1);if(silent)return!0;silent=state.tokens.length;if(isOrdered){var ch=state.push(\"ordered_list_open\",\"ol\",1);1!==listLines&&(ch.attrs=[[\"start\",listLines]])}else ch=state.push(\"bullet_list_open\",\"ul\",1);ch.map=listLines=[startLine,0];ch.markup=String.fromCharCode(markerCharCode);\nvar contentStart=startLine;var prevEmptyEnd=!1;var terminatorRules=state.md.block.ruler.getRules(\"list\");var oldParentType=state.parentType;for(state.parentType=\"list\";contentStart<endLine;){var indent=l;var i=state.eMarks[contentStart];for(initial=l=state.sCount[contentStart]+l-(state.bMarks[startLine]+state.tShift[startLine]);indent<i;){ch=state.src.charCodeAt(indent);if(9===ch)l+=4-(l+state.bsCount[contentStart])%4;else if(32===ch)l++;else break;indent++}contentStart=indent;indent=contentStart>=\ni?1:l-initial;4<indent&&(indent=1);indent=initial+indent;ch=state.push(\"list_item_open\",\"li\",1);ch.markup=String.fromCharCode(markerCharCode);ch.map=initial=[startLine,0];var oldTight=state.tight;var oldTShift=state.tShift[startLine];var oldSCount=state.sCount[startLine];ch=state.listIndent;state.listIndent=state.blkIndent;state.blkIndent=indent;state.tight=!0;state.tShift[startLine]=contentStart-state.bMarks[startLine];state.sCount[startLine]=l;contentStart>=i&&state.isEmpty(startLine+1)?state.line=\nMath.min(state.line+2,endLine):state.md.block.tokenize(state,startLine,endLine,!0);if(!state.tight||prevEmptyEnd)tight=!1;prevEmptyEnd=1<state.line-startLine&&state.isEmpty(state.line-1);state.blkIndent=state.listIndent;state.listIndent=ch;state.tShift[startLine]=oldTShift;state.sCount[startLine]=oldSCount;state.tight=oldTight;ch=state.push(\"list_item_close\",\"li\",-1);ch.markup=String.fromCharCode(markerCharCode);contentStart=startLine=state.line;initial[1]=contentStart;if(contentStart>=endLine)break;\nif(state.sCount[contentStart]<state.blkIndent)break;if(4<=state.sCount[startLine]-state.blkIndent)break;initial=!1;i=0;for(l=terminatorRules.length;i<l;i++)if(terminatorRules[i](state,contentStart,endLine,!0)){initial=!0;break}if(initial)break;l=isOrdered?skipOrderedListMarker(state,contentStart):skipBulletListMarker(state,contentStart);if(0>l)break;if(markerCharCode!==state.src.charCodeAt(l-1))break}ch=isOrdered?state.push(\"ordered_list_close\",\"ol\",-1):state.push(\"bullet_list_close\",\"ul\",-1);ch.markup=\nString.fromCharCode(markerCharCode);listLines[1]=contentStart;state.line=contentStart;state.parentType=oldParentType;if(tight)for(startLine=state.level+2,endLine=silent+2,isOrdered=state.tokens.length-2;endLine<isOrdered;endLine++)state.tokens[endLine].level===startLine&&\"paragraph_open\"===state.tokens[endLine].type&&(state.tokens[endLine+2].hidden=!0,state.tokens[endLine].hidden=!0,endLine+=2);return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$list\"] = function(global,require,module,exports) {\n// Lists\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[startLine] - state.listIndent >= 4 &&\n      state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.tShift[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n\n    // change current state, then restore it after parser subcall\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$markdown_it$lib$common$utils"]],"~:properties",["^5",["map","attrs","listIndent","blkIndent","markup","tight","line","hidden","parentType"]],"~:compiled-at",1591107371172,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_block$list.js\",\n\"lineCount\":9,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_block/list.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_block$list\\\"] = function(global,require,module,exports) {\\n// Lists\\n\\n'use strict';\\n\\nvar isSpace = require('../common/utils').isSpace;\\n\\n\\n// Search `[-+*][\\\\n ]`, returns next pos after marker on success\\n// or -1 on fail.\\nfunction skipBulletListMarker(state, startLine) {\\n  var marker, pos, max, ch;\\n\\n  pos = state.bMarks[startLine] + state.tShift[startLine];\\n  max = state.eMarks[startLine];\\n\\n  marker = state.src.charCodeAt(pos++);\\n  // Check bullet\\n  if (marker !== 0x2A/* * */ &&\\n      marker !== 0x2D/* - */ &&\\n      marker !== 0x2B/* + */) {\\n    return -1;\\n  }\\n\\n  if (pos < max) {\\n    ch = state.src.charCodeAt(pos);\\n\\n    if (!isSpace(ch)) {\\n      // \\\" -test \\\" - is not a list item\\n      return -1;\\n    }\\n  }\\n\\n  return pos;\\n}\\n\\n// Search `\\\\d+[.)][\\\\n ]`, returns next pos after marker on success\\n// or -1 on fail.\\nfunction skipOrderedListMarker(state, startLine) {\\n  var ch,\\n      start = state.bMarks[startLine] + state.tShift[startLine],\\n      pos = start,\\n      max = state.eMarks[startLine];\\n\\n  // List marker should have at least 2 chars (digit + dot)\\n  if (pos + 1 >= max) { return -1; }\\n\\n  ch = state.src.charCodeAt(pos++);\\n\\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\\n\\n  for (;;) {\\n    // EOL -> fail\\n    if (pos >= max) { return -1; }\\n\\n    ch = state.src.charCodeAt(pos++);\\n\\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\\n\\n      // List marker should have no more than 9 digits\\n      // (prevents integer overflow in browsers)\\n      if (pos - start >= 10) { return -1; }\\n\\n      continue;\\n    }\\n\\n    // found valid marker\\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\\n      break;\\n    }\\n\\n    return -1;\\n  }\\n\\n\\n  if (pos < max) {\\n    ch = state.src.charCodeAt(pos);\\n\\n    if (!isSpace(ch)) {\\n      // \\\" 1.test \\\" - is not a list item\\n      return -1;\\n    }\\n  }\\n  return pos;\\n}\\n\\nfunction markTightParagraphs(state, idx) {\\n  var i, l,\\n      level = state.level + 2;\\n\\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\\n      state.tokens[i + 2].hidden = true;\\n      state.tokens[i].hidden = true;\\n      i += 2;\\n    }\\n  }\\n}\\n\\n\\nmodule.exports = function list(state, startLine, endLine, silent) {\\n  var ch,\\n      contentStart,\\n      i,\\n      indent,\\n      indentAfterMarker,\\n      initial,\\n      isOrdered,\\n      itemLines,\\n      l,\\n      listLines,\\n      listTokIdx,\\n      markerCharCode,\\n      markerValue,\\n      max,\\n      nextLine,\\n      offset,\\n      oldListIndent,\\n      oldParentType,\\n      oldSCount,\\n      oldTShift,\\n      oldTight,\\n      pos,\\n      posAfterMarker,\\n      prevEmptyEnd,\\n      start,\\n      terminate,\\n      terminatorRules,\\n      token,\\n      isTerminatingParagraph = false,\\n      tight = true;\\n\\n  // if it's indented more than 3 spaces, it should be a code block\\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\\n\\n  // Special case:\\n  //  - item 1\\n  //   - item 2\\n  //    - item 3\\n  //     - item 4\\n  //      - this one is a paragraph continuation\\n  if (state.listIndent >= 0 &&\\n      state.sCount[startLine] - state.listIndent >= 4 &&\\n      state.sCount[startLine] < state.blkIndent) {\\n    return false;\\n  }\\n\\n  // limit conditions when list can interrupt\\n  // a paragraph (validation mode only)\\n  if (silent && state.parentType === 'paragraph') {\\n    // Next list item should still terminate previous list item;\\n    //\\n    // This code can fail if plugins use blkIndent as well as lists,\\n    // but I hope the spec gets fixed long before that happens.\\n    //\\n    if (state.tShift[startLine] >= state.blkIndent) {\\n      isTerminatingParagraph = true;\\n    }\\n  }\\n\\n  // Detect list type and position after marker\\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\\n    isOrdered = true;\\n    start = state.bMarks[startLine] + state.tShift[startLine];\\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\\n\\n    // If we're starting a new ordered list right after\\n    // a paragraph, it should start with 1.\\n    if (isTerminatingParagraph && markerValue !== 1) return false;\\n\\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\\n    isOrdered = false;\\n\\n  } else {\\n    return false;\\n  }\\n\\n  // If we're starting a new unordered list right after\\n  // a paragraph, first line should not be empty.\\n  if (isTerminatingParagraph) {\\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\\n  }\\n\\n  // We should terminate list on style change. Remember first one to compare.\\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\\n\\n  // For validation mode we can terminate immediately\\n  if (silent) { return true; }\\n\\n  // Start list\\n  listTokIdx = state.tokens.length;\\n\\n  if (isOrdered) {\\n    token       = state.push('ordered_list_open', 'ol', 1);\\n    if (markerValue !== 1) {\\n      token.attrs = [ [ 'start', markerValue ] ];\\n    }\\n\\n  } else {\\n    token       = state.push('bullet_list_open', 'ul', 1);\\n  }\\n\\n  token.map    = listLines = [ startLine, 0 ];\\n  token.markup = String.fromCharCode(markerCharCode);\\n\\n  //\\n  // Iterate list items\\n  //\\n\\n  nextLine = startLine;\\n  prevEmptyEnd = false;\\n  terminatorRules = state.md.block.ruler.getRules('list');\\n\\n  oldParentType = state.parentType;\\n  state.parentType = 'list';\\n\\n  while (nextLine < endLine) {\\n    pos = posAfterMarker;\\n    max = state.eMarks[nextLine];\\n\\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\\n\\n    while (pos < max) {\\n      ch = state.src.charCodeAt(pos);\\n\\n      if (ch === 0x09) {\\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\\n      } else if (ch === 0x20) {\\n        offset++;\\n      } else {\\n        break;\\n      }\\n\\n      pos++;\\n    }\\n\\n    contentStart = pos;\\n\\n    if (contentStart >= max) {\\n      // trimming space in \\\"-    \\\\n  3\\\" case, indent is 1 here\\n      indentAfterMarker = 1;\\n    } else {\\n      indentAfterMarker = offset - initial;\\n    }\\n\\n    // If we have more than 4 spaces, the indent is 1\\n    // (the rest is just indented code block)\\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\\n\\n    // \\\"  -  test\\\"\\n    //  ^^^^^ - calculating total length of this thing\\n    indent = initial + indentAfterMarker;\\n\\n    // Run subparser & write tokens\\n    token        = state.push('list_item_open', 'li', 1);\\n    token.markup = String.fromCharCode(markerCharCode);\\n    token.map    = itemLines = [ startLine, 0 ];\\n\\n    // change current state, then restore it after parser subcall\\n    oldTight = state.tight;\\n    oldTShift = state.tShift[startLine];\\n    oldSCount = state.sCount[startLine];\\n\\n    //  - example list\\n    // ^ listIndent position will be here\\n    //   ^ blkIndent position will be here\\n    //\\n    oldListIndent = state.listIndent;\\n    state.listIndent = state.blkIndent;\\n    state.blkIndent = indent;\\n\\n    state.tight = true;\\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\\n    state.sCount[startLine] = offset;\\n\\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\\n      // workaround for this case\\n      // (list item is empty, list terminates before \\\"foo\\\"):\\n      // ~~~~~~~~\\n      //   -\\n      //\\n      //     foo\\n      // ~~~~~~~~\\n      state.line = Math.min(state.line + 2, endLine);\\n    } else {\\n      state.md.block.tokenize(state, startLine, endLine, true);\\n    }\\n\\n    // If any of list item is tight, mark list as tight\\n    if (!state.tight || prevEmptyEnd) {\\n      tight = false;\\n    }\\n    // Item become loose if finish with empty line,\\n    // but we should filter last element, because it means list finish\\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\\n\\n    state.blkIndent = state.listIndent;\\n    state.listIndent = oldListIndent;\\n    state.tShift[startLine] = oldTShift;\\n    state.sCount[startLine] = oldSCount;\\n    state.tight = oldTight;\\n\\n    token        = state.push('list_item_close', 'li', -1);\\n    token.markup = String.fromCharCode(markerCharCode);\\n\\n    nextLine = startLine = state.line;\\n    itemLines[1] = nextLine;\\n    contentStart = state.bMarks[startLine];\\n\\n    if (nextLine >= endLine) { break; }\\n\\n    //\\n    // Try to check if list is terminated or continued.\\n    //\\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\\n\\n    // if it's indented more than 3 spaces, it should be a code block\\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\\n\\n    // fail if terminating block found\\n    terminate = false;\\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\\n        terminate = true;\\n        break;\\n      }\\n    }\\n    if (terminate) { break; }\\n\\n    // fail if list has another type\\n    if (isOrdered) {\\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\\n      if (posAfterMarker < 0) { break; }\\n    } else {\\n      posAfterMarker = skipBulletListMarker(state, nextLine);\\n      if (posAfterMarker < 0) { break; }\\n    }\\n\\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\\n  }\\n\\n  // Finalize list\\n  if (isOrdered) {\\n    token = state.push('ordered_list_close', 'ol', -1);\\n  } else {\\n    token = state.push('bullet_list_close', 'ul', -1);\\n  }\\n  token.markup = String.fromCharCode(markerCharCode);\\n\\n  listLines[1] = nextLine;\\n  state.line = nextLine;\\n\\n  state.parentType = oldParentType;\\n\\n  // mark paragraphs tight if needed\\n  if (tight) {\\n    markTightParagraphs(state, listTokIdx);\\n  }\\n\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"skipBulletListMarker\",\"state\",\"startLine\",\"pos\",\"bMarks\",\"tShift\",\"max\",\"eMarks\",\"marker\",\"src\",\"charCodeAt\",\"ch\",\"isSpace\",\"skipOrderedListMarker\",\"start\",\"module.exports\",\"endLine\",\"silent\",\"initial\",\"l\",\"isTerminatingParagraph\",\"tight\",\"sCount\",\"blkIndent\",\"listIndent\",\"parentType\",\"posAfterMarker\",\"isOrdered\",\"markerValue\",\"Number\",\"substr\",\"skipSpaces\",\"markerCharCode\",\"listTokIdx\",\"tokens\",\"length\",\"token\",\"push\",\"attrs\",\"map\",\"listLines\",\"markup\",\"String\",\"fromCharCode\",\"nextLine\",\"prevEmptyEnd\",\"terminatorRules\",\"md\",\"block\",\"ruler\",\"getRules\",\"oldParentType\",\"offset\",\"bsCount\",\"contentStart\",\"indentAfterMarker\",\"indent\",\"itemLines\",\"oldTight\",\"oldTShift\",\"oldSCount\",\"oldListIndent\",\"isEmpty\",\"line\",\"Math\",\"min\",\"tokenize\",\"terminate\",\"i\",\"level\",\"type\",\"hidden\"]\n}\n"]