["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_block/blockquote.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_block$blockquote=function(global,require,module,exports){var isSpace=require(\"module$node_modules$markdown_it$lib$common$utils\").isSpace;module.exports=function(state,startLine,endLine,silent){var offset,oldLineMax=state.lineMax;var i=state.bMarks[startLine]+state.tShift[startLine];var l=state.eMarks[startLine];if(4<=state.sCount[startLine]-state.blkIndent||62!==state.src.charCodeAt(i++))return!1;if(silent)return!0;var initial=offset=state.sCount[startLine]+\ni-(state.bMarks[startLine]+state.tShift[startLine]);if(32===state.src.charCodeAt(i)){i++;initial++;offset++;var adjustTab=!1;var spaceAfterMarker=!0}else 9===state.src.charCodeAt(i)?(spaceAfterMarker=!0,3===(state.bsCount[startLine]+offset)%4?(i++,initial++,offset++,adjustTab=!1):adjustTab=!0):spaceAfterMarker=!1;var oldBMarks=[state.bMarks[startLine]];for(state.bMarks[startLine]=i;i<l;){var ch=state.src.charCodeAt(i);if(isSpace(ch))9===ch?offset+=4-(offset+state.bsCount[startLine]+(adjustTab?1:0))%\n4:offset++;else break;i++}var oldBSCount=[state.bsCount[startLine]];state.bsCount[startLine]=state.sCount[startLine]+1+(spaceAfterMarker?1:0);ch=i>=l;var oldSCount=[state.sCount[startLine]];state.sCount[startLine]=offset-initial;var oldTShift=[state.tShift[startLine]];state.tShift[startLine]=i-state.bMarks[startLine];var terminatorRules=state.md.block.ruler.getRules(\"blockquote\");var oldParentType=state.parentType;state.parentType=\"blockquote\";var wasOutdented=!1;for(silent=startLine+1;silent<endLine;silent++){state.sCount[silent]<\nstate.blkIndent&&(wasOutdented=!0);i=state.bMarks[silent]+state.tShift[silent];l=state.eMarks[silent];if(i>=l)break;if(62!==state.src.charCodeAt(i++)||wasOutdented){if(ch)break;initial=!1;i=0;for(l=terminatorRules.length;i<l;i++)if(terminatorRules[i](state,silent,endLine,!0)){initial=!0;break}if(initial){state.lineMax=silent;0!==state.blkIndent&&(oldBMarks.push(state.bMarks[silent]),oldBSCount.push(state.bsCount[silent]),oldTShift.push(state.tShift[silent]),oldSCount.push(state.sCount[silent]),state.sCount[silent]-=\nstate.blkIndent);break}oldBMarks.push(state.bMarks[silent]);oldBSCount.push(state.bsCount[silent]);oldTShift.push(state.tShift[silent]);oldSCount.push(state.sCount[silent]);state.sCount[silent]=-1}else{initial=offset=state.sCount[silent]+i-(state.bMarks[silent]+state.tShift[silent]);32===state.src.charCodeAt(i)?(i++,initial++,offset++,adjustTab=!1,spaceAfterMarker=!0):9===state.src.charCodeAt(i)?(spaceAfterMarker=!0,3===(state.bsCount[silent]+offset)%4?(i++,initial++,offset++,adjustTab=!1):adjustTab=\n!0):spaceAfterMarker=!1;oldBMarks.push(state.bMarks[silent]);for(state.bMarks[silent]=i;i<l;){ch=state.src.charCodeAt(i);if(isSpace(ch))9===ch?offset+=4-(offset+state.bsCount[silent]+(adjustTab?1:0))%4:offset++;else break;i++}ch=i>=l;oldBSCount.push(state.bsCount[silent]);state.bsCount[silent]=state.sCount[silent]+1+(spaceAfterMarker?1:0);oldSCount.push(state.sCount[silent]);state.sCount[silent]=offset-initial;oldTShift.push(state.tShift[silent]);state.tShift[silent]=i-state.bMarks[silent]}}endLine=\nstate.blkIndent;state.blkIndent=0;terminatorRules=state.push(\"blockquote_open\",\"blockquote\",1);terminatorRules.markup=\"\\x3e\";terminatorRules.map=adjustTab=[startLine,0];state.md.block.tokenize(state,startLine,silent);terminatorRules=state.push(\"blockquote_close\",\"blockquote\",-1);terminatorRules.markup=\"\\x3e\";state.lineMax=oldLineMax;state.parentType=oldParentType;adjustTab[1]=state.line;for(i=0;i<oldTShift.length;i++)state.bMarks[i+startLine]=oldBMarks[i],state.tShift[i+startLine]=oldTShift[i],state.sCount[i+\nstartLine]=oldSCount[i],state.bsCount[i+startLine]=oldBSCount[i];state.blkIndent=endLine;return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$blockquote\"] = function(global,require,module,exports) {\n// Block quotes\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      wasOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // skip spaces after \">\" and re-calculate offset\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  wasOutdented = false;\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !wasOutdented) {\n      // This line is inside the blockquote.\n\n      // skip spaces after \">\" and re-calculate offset\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$markdown_it$lib$common$utils"]],"~:properties",["^5",["map","blkIndent","markup","lineMax","parentType"]],"~:compiled-at",1591107371171,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_block$blockquote.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_block/blockquote.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_block$blockquote\\\"] = function(global,require,module,exports) {\\n// Block quotes\\n\\n'use strict';\\n\\nvar isSpace = require('../common/utils').isSpace;\\n\\n\\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\\n  var adjustTab,\\n      ch,\\n      i,\\n      initial,\\n      l,\\n      lastLineEmpty,\\n      lines,\\n      nextLine,\\n      offset,\\n      oldBMarks,\\n      oldBSCount,\\n      oldIndent,\\n      oldParentType,\\n      oldSCount,\\n      oldTShift,\\n      spaceAfterMarker,\\n      terminate,\\n      terminatorRules,\\n      token,\\n      wasOutdented,\\n      oldLineMax = state.lineMax,\\n      pos = state.bMarks[startLine] + state.tShift[startLine],\\n      max = state.eMarks[startLine];\\n\\n  // if it's indented more than 3 spaces, it should be a code block\\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\\n\\n  // check the block quote marker\\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\\n\\n  // we know that it's going to be a valid blockquote,\\n  // so no point trying to find the end of it in silent mode\\n  if (silent) { return true; }\\n\\n  // skip spaces after \\\">\\\" and re-calculate offset\\n  initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);\\n\\n  // skip one optional space after '>'\\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\\n    // ' >   test '\\n    //     ^ -- position start of line here:\\n    pos++;\\n    initial++;\\n    offset++;\\n    adjustTab = false;\\n    spaceAfterMarker = true;\\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\\n    spaceAfterMarker = true;\\n\\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\\n      // '  >\\\\t  test '\\n      //       ^ -- position start of line here (tab has width===1)\\n      pos++;\\n      initial++;\\n      offset++;\\n      adjustTab = false;\\n    } else {\\n      // ' >\\\\t  test '\\n      //    ^ -- position start of line here + shift bsCount slightly\\n      //         to make extra space appear\\n      adjustTab = true;\\n    }\\n  } else {\\n    spaceAfterMarker = false;\\n  }\\n\\n  oldBMarks = [ state.bMarks[startLine] ];\\n  state.bMarks[startLine] = pos;\\n\\n  while (pos < max) {\\n    ch = state.src.charCodeAt(pos);\\n\\n    if (isSpace(ch)) {\\n      if (ch === 0x09) {\\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\\n      } else {\\n        offset++;\\n      }\\n    } else {\\n      break;\\n    }\\n\\n    pos++;\\n  }\\n\\n  oldBSCount = [ state.bsCount[startLine] ];\\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\\n\\n  lastLineEmpty = pos >= max;\\n\\n  oldSCount = [ state.sCount[startLine] ];\\n  state.sCount[startLine] = offset - initial;\\n\\n  oldTShift = [ state.tShift[startLine] ];\\n  state.tShift[startLine] = pos - state.bMarks[startLine];\\n\\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\\n\\n  oldParentType = state.parentType;\\n  state.parentType = 'blockquote';\\n  wasOutdented = false;\\n\\n  // Search the end of the block\\n  //\\n  // Block ends with either:\\n  //  1. an empty line outside:\\n  //     ```\\n  //     > test\\n  //\\n  //     ```\\n  //  2. an empty line inside:\\n  //     ```\\n  //     >\\n  //     test\\n  //     ```\\n  //  3. another tag:\\n  //     ```\\n  //     > test\\n  //      - - -\\n  //     ```\\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\\n    // check if it's outdented, i.e. it's inside list item and indented\\n    // less than said list item:\\n    //\\n    // ```\\n    // 1. anything\\n    //    > current blockquote\\n    // 2. checking this line\\n    // ```\\n    if (state.sCount[nextLine] < state.blkIndent) wasOutdented = true;\\n\\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\\n    max = state.eMarks[nextLine];\\n\\n    if (pos >= max) {\\n      // Case 1: line is not inside the blockquote, and this line is empty.\\n      break;\\n    }\\n\\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !wasOutdented) {\\n      // This line is inside the blockquote.\\n\\n      // skip spaces after \\\">\\\" and re-calculate offset\\n      initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);\\n\\n      // skip one optional space after '>'\\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\\n        // ' >   test '\\n        //     ^ -- position start of line here:\\n        pos++;\\n        initial++;\\n        offset++;\\n        adjustTab = false;\\n        spaceAfterMarker = true;\\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\\n        spaceAfterMarker = true;\\n\\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\\n          // '  >\\\\t  test '\\n          //       ^ -- position start of line here (tab has width===1)\\n          pos++;\\n          initial++;\\n          offset++;\\n          adjustTab = false;\\n        } else {\\n          // ' >\\\\t  test '\\n          //    ^ -- position start of line here + shift bsCount slightly\\n          //         to make extra space appear\\n          adjustTab = true;\\n        }\\n      } else {\\n        spaceAfterMarker = false;\\n      }\\n\\n      oldBMarks.push(state.bMarks[nextLine]);\\n      state.bMarks[nextLine] = pos;\\n\\n      while (pos < max) {\\n        ch = state.src.charCodeAt(pos);\\n\\n        if (isSpace(ch)) {\\n          if (ch === 0x09) {\\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\\n          } else {\\n            offset++;\\n          }\\n        } else {\\n          break;\\n        }\\n\\n        pos++;\\n      }\\n\\n      lastLineEmpty = pos >= max;\\n\\n      oldBSCount.push(state.bsCount[nextLine]);\\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\\n\\n      oldSCount.push(state.sCount[nextLine]);\\n      state.sCount[nextLine] = offset - initial;\\n\\n      oldTShift.push(state.tShift[nextLine]);\\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\\n      continue;\\n    }\\n\\n    // Case 2: line is not inside the blockquote, and the last line was empty.\\n    if (lastLineEmpty) { break; }\\n\\n    // Case 3: another tag found.\\n    terminate = false;\\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\\n        terminate = true;\\n        break;\\n      }\\n    }\\n\\n    if (terminate) {\\n      // Quirk to enforce \\\"hard termination mode\\\" for paragraphs;\\n      // normally if you call `tokenize(state, startLine, nextLine)`,\\n      // paragraphs will look below nextLine for paragraph continuation,\\n      // but if blockquote is terminated by another tag, they shouldn't\\n      state.lineMax = nextLine;\\n\\n      if (state.blkIndent !== 0) {\\n        // state.blkIndent was non-zero, we now set it to zero,\\n        // so we need to re-calculate all offsets to appear as\\n        // if indent wasn't changed\\n        oldBMarks.push(state.bMarks[nextLine]);\\n        oldBSCount.push(state.bsCount[nextLine]);\\n        oldTShift.push(state.tShift[nextLine]);\\n        oldSCount.push(state.sCount[nextLine]);\\n        state.sCount[nextLine] -= state.blkIndent;\\n      }\\n\\n      break;\\n    }\\n\\n    oldBMarks.push(state.bMarks[nextLine]);\\n    oldBSCount.push(state.bsCount[nextLine]);\\n    oldTShift.push(state.tShift[nextLine]);\\n    oldSCount.push(state.sCount[nextLine]);\\n\\n    // A negative indentation means that this is a paragraph continuation\\n    //\\n    state.sCount[nextLine] = -1;\\n  }\\n\\n  oldIndent = state.blkIndent;\\n  state.blkIndent = 0;\\n\\n  token        = state.push('blockquote_open', 'blockquote', 1);\\n  token.markup = '>';\\n  token.map    = lines = [ startLine, 0 ];\\n\\n  state.md.block.tokenize(state, startLine, nextLine);\\n\\n  token        = state.push('blockquote_close', 'blockquote', -1);\\n  token.markup = '>';\\n\\n  state.lineMax = oldLineMax;\\n  state.parentType = oldParentType;\\n  lines[1] = state.line;\\n\\n  // Restore original tShift; this might not be necessary since the parser\\n  // has already been here, but just to make sure we can do that.\\n  for (i = 0; i < oldTShift.length; i++) {\\n    state.bMarks[i + startLine] = oldBMarks[i];\\n    state.tShift[i + startLine] = oldTShift[i];\\n    state.sCount[i + startLine] = oldSCount[i];\\n    state.bsCount[i + startLine] = oldBSCount[i];\\n  }\\n  state.blkIndent = oldIndent;\\n\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isSpace\",\"module.exports\",\"state\",\"startLine\",\"endLine\",\"silent\",\"offset\",\"oldLineMax\",\"lineMax\",\"pos\",\"bMarks\",\"tShift\",\"max\",\"eMarks\",\"sCount\",\"blkIndent\",\"src\",\"charCodeAt\",\"initial\",\"adjustTab\",\"spaceAfterMarker\",\"bsCount\",\"oldBMarks\",\"ch\",\"oldBSCount\",\"lastLineEmpty\",\"oldSCount\",\"oldTShift\",\"terminatorRules\",\"md\",\"block\",\"ruler\",\"getRules\",\"oldParentType\",\"parentType\",\"wasOutdented\",\"nextLine\",\"terminate\",\"i\",\"l\",\"length\",\"push\",\"oldIndent\",\"token\",\"markup\",\"map\",\"lines\",\"tokenize\",\"line\"]\n}\n"]