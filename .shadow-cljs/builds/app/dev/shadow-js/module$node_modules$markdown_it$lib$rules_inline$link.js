["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_inline/link.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_inline$link=function(global,require,module,exports){var normalizeReference=require(\"module$node_modules$markdown_it$lib$common$utils\").normalizeReference,isSpace=require(\"module$node_modules$markdown_it$lib$common$utils\").isSpace;module.exports=function(state,silent){var label,ref;var attrs=\"\";var oldPos=state.pos,max=state.posMax,parseReference=!0;if(91!==state.src.charCodeAt(state.pos))return!1;var labelStart=state.pos+1;var labelEnd=state.md.helpers.parseLinkLabel(state,\nstate.pos,!0);if(0>labelEnd)return!1;var pos=labelEnd+1;if(pos<max&&40===state.src.charCodeAt(pos)){parseReference=!1;for(pos++;pos<max;pos++){var code=state.src.charCodeAt(pos);if(!isSpace(code)&&10!==code)break}if(pos>=max)return!1;code=state.md.helpers.parseLinkDestination(state.src,pos,state.posMax);code.ok&&(attrs=state.md.normalizeLink(code.str),state.md.validateLink(attrs)?pos=code.pos:attrs=\"\");for(ref=pos;pos<max&&(code=state.src.charCodeAt(pos),isSpace(code)||10===code);pos++);code=state.md.helpers.parseLinkTitle(state.src,\npos,state.posMax);if(pos<max&&ref!==pos&&code.ok)for(ref=code.str,pos=code.pos;pos<max&&(code=state.src.charCodeAt(pos),isSpace(code)||10===code);pos++);else ref=\"\";if(pos>=max||41!==state.src.charCodeAt(pos))parseReference=!0;pos++}if(parseReference){if(\"undefined\"===typeof state.env.references)return!1;pos<max&&91===state.src.charCodeAt(pos)?(ref=pos+1,pos=state.md.helpers.parseLinkLabel(state,pos),0<=pos?label=state.src.slice(ref,pos++):pos=labelEnd+1):pos=labelEnd+1;label||(label=state.src.slice(labelStart,\nlabelEnd));ref=state.env.references[normalizeReference(label)];if(!ref)return state.pos=oldPos,!1;attrs=ref.href;ref=ref.title}silent||(state.pos=labelStart,state.posMax=labelEnd,silent=state.push(\"link_open\",\"a\",1),silent.attrs=attrs=[[\"href\",attrs]],ref&&attrs.push([\"title\",ref]),state.md.inline.tokenize(state),state.push(\"link_close\",\"a\",-1));state.pos=pos;state.posMax=max;return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$link\"] = function(global,require,module,exports) {\n// Process [link](<to> \"stuff\")\n\n'use strict';\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function link(state, silent) {\n  var attrs,\n      code,\n      label,\n      labelEnd,\n      labelStart,\n      pos,\n      res,\n      ref,\n      title,\n      token,\n      href = '',\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      parseReference = true;\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\n\n  labelStart = state.pos + 1;\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false; }\n\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false;\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n    if (pos >= max) { return false; }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) { break; }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) { break; }\n      }\n    } else {\n      title = '';\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true;\n    }\n    pos++;\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false; }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\n\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    token        = state.push('link_open', 'a', 1);\n    token.attrs  = attrs = [ [ 'href', href ] ];\n    if (title) {\n      attrs.push([ 'title', title ]);\n    }\n\n    state.md.inline.tokenize(state);\n\n    token        = state.push('link_close', 'a', -1);\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$markdown_it$lib$common$utils"]],"~:properties",["^5",["attrs","pos","posMax"]],"~:compiled-at",1591107371176,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_inline$link.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_inline/link.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_inline$link\\\"] = function(global,require,module,exports) {\\n// Process [link](<to> \\\"stuff\\\")\\n\\n'use strict';\\n\\nvar normalizeReference   = require('../common/utils').normalizeReference;\\nvar isSpace              = require('../common/utils').isSpace;\\n\\n\\nmodule.exports = function link(state, silent) {\\n  var attrs,\\n      code,\\n      label,\\n      labelEnd,\\n      labelStart,\\n      pos,\\n      res,\\n      ref,\\n      title,\\n      token,\\n      href = '',\\n      oldPos = state.pos,\\n      max = state.posMax,\\n      start = state.pos,\\n      parseReference = true;\\n\\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }\\n\\n  labelStart = state.pos + 1;\\n  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\\n\\n  // parser failed to find ']', so it's not a valid link\\n  if (labelEnd < 0) { return false; }\\n\\n  pos = labelEnd + 1;\\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\\n    //\\n    // Inline link\\n    //\\n\\n    // might have found a valid shortcut link, disable reference parsing\\n    parseReference = false;\\n\\n    // [link](  <href>  \\\"title\\\"  )\\n    //        ^^ skipping these spaces\\n    pos++;\\n    for (; pos < max; pos++) {\\n      code = state.src.charCodeAt(pos);\\n      if (!isSpace(code) && code !== 0x0A) { break; }\\n    }\\n    if (pos >= max) { return false; }\\n\\n    // [link](  <href>  \\\"title\\\"  )\\n    //          ^^^^^^ parsing link destination\\n    start = pos;\\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\\n    if (res.ok) {\\n      href = state.md.normalizeLink(res.str);\\n      if (state.md.validateLink(href)) {\\n        pos = res.pos;\\n      } else {\\n        href = '';\\n      }\\n    }\\n\\n    // [link](  <href>  \\\"title\\\"  )\\n    //                ^^ skipping these spaces\\n    start = pos;\\n    for (; pos < max; pos++) {\\n      code = state.src.charCodeAt(pos);\\n      if (!isSpace(code) && code !== 0x0A) { break; }\\n    }\\n\\n    // [link](  <href>  \\\"title\\\"  )\\n    //                  ^^^^^^^ parsing link title\\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\\n    if (pos < max && start !== pos && res.ok) {\\n      title = res.str;\\n      pos = res.pos;\\n\\n      // [link](  <href>  \\\"title\\\"  )\\n      //                         ^^ skipping these spaces\\n      for (; pos < max; pos++) {\\n        code = state.src.charCodeAt(pos);\\n        if (!isSpace(code) && code !== 0x0A) { break; }\\n      }\\n    } else {\\n      title = '';\\n    }\\n\\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\\n      // parsing a valid shortcut link failed, fallback to reference\\n      parseReference = true;\\n    }\\n    pos++;\\n  }\\n\\n  if (parseReference) {\\n    //\\n    // Link reference\\n    //\\n    if (typeof state.env.references === 'undefined') { return false; }\\n\\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\\n      start = pos + 1;\\n      pos = state.md.helpers.parseLinkLabel(state, pos);\\n      if (pos >= 0) {\\n        label = state.src.slice(start, pos++);\\n      } else {\\n        pos = labelEnd + 1;\\n      }\\n    } else {\\n      pos = labelEnd + 1;\\n    }\\n\\n    // covers label === '' and label === undefined\\n    // (collapsed reference link and shortcut reference link respectively)\\n    if (!label) { label = state.src.slice(labelStart, labelEnd); }\\n\\n    ref = state.env.references[normalizeReference(label)];\\n    if (!ref) {\\n      state.pos = oldPos;\\n      return false;\\n    }\\n    href = ref.href;\\n    title = ref.title;\\n  }\\n\\n  //\\n  // We found the end of the link, and know for a fact it's a valid link;\\n  // so all that's left to do is to call tokenizer.\\n  //\\n  if (!silent) {\\n    state.pos = labelStart;\\n    state.posMax = labelEnd;\\n\\n    token        = state.push('link_open', 'a', 1);\\n    token.attrs  = attrs = [ [ 'href', href ] ];\\n    if (title) {\\n      attrs.push([ 'title', title ]);\\n    }\\n\\n    state.md.inline.tokenize(state);\\n\\n    token        = state.push('link_close', 'a', -1);\\n  }\\n\\n  state.pos = pos;\\n  state.posMax = max;\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"normalizeReference\",\"isSpace\",\"module.exports\",\"state\",\"silent\",\"label\",\"ref\",\"href\",\"oldPos\",\"pos\",\"max\",\"posMax\",\"parseReference\",\"src\",\"charCodeAt\",\"labelStart\",\"labelEnd\",\"md\",\"helpers\",\"parseLinkLabel\",\"code\",\"res\",\"parseLinkDestination\",\"ok\",\"normalizeLink\",\"str\",\"validateLink\",\"start\",\"parseLinkTitle\",\"title\",\"env\",\"references\",\"slice\",\"token\",\"push\",\"attrs\",\"inline\",\"tokenize\"]\n}\n"]