["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_inline/text.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_inline$text=function(global,require,module,exports){function isTerminatorChar(ch){switch(ch){case 10:case 33:case 35:case 36:case 37:case 38:case 42:case 43:case 45:case 58:case 60:case 61:case 62:case 64:case 91:case 92:case 93:case 94:case 95:case 96:case 123:case 125:case 126:return!0;default:return!1}}module.exports=function(state,silent){for(var pos=state.pos;pos<state.posMax&&!isTerminatorChar(state.src.charCodeAt(pos));)pos++;if(pos===\nstate.pos)return!1;silent||(state.pending+=state.src.slice(state.pos,pos));state.pos=pos;return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$text\"] = function(global,require,module,exports) {\n// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n'use strict';\n\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) { return false; }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\n\n  state.pos = pos;\n\n  return true;\n};\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParcerInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n};*/\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["pos","pending"]],"~:compiled-at",1591107371175,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_inline$text.js\",\n\"lineCount\":2,\n\"mappings\":\"AAAAA,cAAA,sDAAA,CAA0E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAclHC,QAASA,iBAAgB,CAACC,EAAD,CAAK,CAC5B,OAAQA,EAAR,EACE,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,EAAL,CACA,KAAK,GAAL,CACA,KAAK,GAAL,CACA,KAAK,GAAL,CACE,MAAO,CAAA,CACT,SACE,MAAO,CAAA,CA1BX,CAD4B,CA+B9BH,MAAAC,QAAA,CAAiBG,QAAa,CAACC,KAAD,CAAQC,MAAR,CAAgB,CAG5C,IAFA,IAAIC,IAAMF,KAAAE,IAEV,CAAOA,GAAP,CAAaF,KAAAG,OAAb,EAA6B,CAACN,gBAAA,CAAiBG,KAAAI,IAAAC,WAAA,CAAqBH,GAArB,CAAjB,CAA9B,CAAA,CACEA,GAAA,EAGF,IAAIA,GAAJ;AAAYF,KAAAE,IAAZ,CAAyB,MAAO,CAAA,CAE3BD,OAAL,GAAeD,KAAAM,QAAf,EAAgCN,KAAAI,IAAAG,MAAA,CAAgBP,KAAAE,IAAhB,CAA2BA,GAA3B,CAAhC,CAEAF,MAAAE,IAAA,CAAYA,GAEZ,OAAO,CAAA,CAbqC,CA7CoE;\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_inline/text.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_inline$text\\\"] = function(global,require,module,exports) {\\n// Skip text characters for text token, place those to pending buffer\\n// and increment current pos\\n\\n'use strict';\\n\\n\\n// Rule to skip pure text\\n// '{}$%@~+=:' reserved for extentions\\n\\n// !, \\\", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\\\, ], ^, _, `, {, |, }, or ~\\n\\n// !!!! Don't confuse with \\\"Markdown ASCII Punctuation\\\" chars\\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\\nfunction isTerminatorChar(ch) {\\n  switch (ch) {\\n    case 0x0A/* \\\\n */:\\n    case 0x21/* ! */:\\n    case 0x23/* # */:\\n    case 0x24/* $ */:\\n    case 0x25/* % */:\\n    case 0x26/* & */:\\n    case 0x2A/* * */:\\n    case 0x2B/* + */:\\n    case 0x2D/* - */:\\n    case 0x3A/* : */:\\n    case 0x3C/* < */:\\n    case 0x3D/* = */:\\n    case 0x3E/* > */:\\n    case 0x40/* @ */:\\n    case 0x5B/* [ */:\\n    case 0x5C/* \\\\ */:\\n    case 0x5D/* ] */:\\n    case 0x5E/* ^ */:\\n    case 0x5F/* _ */:\\n    case 0x60/* ` */:\\n    case 0x7B/* { */:\\n    case 0x7D/* } */:\\n    case 0x7E/* ~ */:\\n      return true;\\n    default:\\n      return false;\\n  }\\n}\\n\\nmodule.exports = function text(state, silent) {\\n  var pos = state.pos;\\n\\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\\n    pos++;\\n  }\\n\\n  if (pos === state.pos) { return false; }\\n\\n  if (!silent) { state.pending += state.src.slice(state.pos, pos); }\\n\\n  state.pos = pos;\\n\\n  return true;\\n};\\n\\n// Alternative implementation, for memory.\\n//\\n// It costs 10% of performance, but allows extend terminators list, if place it\\n// to `ParcerInline` property. Probably, will switch to it sometime, such\\n// flexibility required.\\n\\n/*\\nvar TERMINATOR_RE = /[\\\\n!#$%&*+\\\\-:<=>@[\\\\\\\\\\\\]^_`{}~]/;\\n\\nmodule.exports = function text(state, silent) {\\n  var pos = state.pos,\\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\\n\\n  // first char is terminator -> empty text\\n  if (idx === 0) { return false; }\\n\\n  // no terminator -> text till end of string\\n  if (idx < 0) {\\n    if (!silent) { state.pending += state.src.slice(pos); }\\n    state.pos = state.src.length;\\n    return true;\\n  }\\n\\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\\n\\n  state.pos += idx;\\n\\n  return true;\\n};*/\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"isTerminatorChar\",\"ch\",\"module.exports\",\"state\",\"silent\",\"pos\",\"posMax\",\"src\",\"charCodeAt\",\"pending\",\"slice\"]\n}\n"]