["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_core/smartquotes.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_core$smartquotes=function(global,require,module,exports){function replaceAt(str,index,ch){return str.substr(0,index)+ch+str.substr(index+1)}var isWhiteSpace=require(\"module$node_modules$markdown_it$lib$common$utils\").isWhiteSpace,isPunctChar=require(\"module$node_modules$markdown_it$lib$common$utils\").isPunctChar,isMdAsciiPunct=require(\"module$node_modules$markdown_it$lib$common$utils\").isMdAsciiPunct,QUOTE_TEST_RE=/['\"]/,QUOTE_RE=/['\"]/g;module.exports=\nfunction(state$jscomp$0){var blkIdx;if(state$jscomp$0.md.options.typographer)for(blkIdx=state$jscomp$0.tokens.length-1;0<=blkIdx;blkIdx--)if(\"inline\"===state$jscomp$0.tokens[blkIdx].type&&QUOTE_TEST_RE.test(state$jscomp$0.tokens[blkIdx].content)){var openQuote,j,i,tokens=state$jscomp$0.tokens[blkIdx].children,state=state$jscomp$0;var stack=[];for(i=0;i<tokens.length;i++){var token=tokens[i];var thisLevel=tokens[i].level;for(j=stack.length-1;0<=j&&!(stack[j].level<=thisLevel);j--);stack.length=j+1;\nif(\"text\"===token.type){var text=token.content;var pos=0;var max=text.length;a:for(;pos<max;){QUOTE_RE.lastIndex=pos;var t=QUOTE_RE.exec(text);if(!t)break;var canOpen=openQuote=!0;pos=t.index+1;var closeQuote=\"'\"===t[0];var lastChar=32;if(0<=t.index-1)lastChar=text.charCodeAt(t.index-1);else for(j=i-1;0<=j&&\"softbreak\"!==tokens[j].type&&\"hardbreak\"!==tokens[j].type;j--)if(\"text\"===tokens[j].type){lastChar=tokens[j].content.charCodeAt(tokens[j].content.length-1);break}var nextChar=32;if(pos<max)nextChar=\ntext.charCodeAt(pos);else for(j=i+1;j<tokens.length&&\"softbreak\"!==tokens[j].type&&\"hardbreak\"!==tokens[j].type;j++)if(\"text\"===tokens[j].type){nextChar=tokens[j].content.charCodeAt(0);break}var isLastPunctChar=isMdAsciiPunct(lastChar)||isPunctChar(String.fromCharCode(lastChar));var isNextPunctChar=isMdAsciiPunct(nextChar)||isPunctChar(String.fromCharCode(nextChar));var isLastWhiteSpace=isWhiteSpace(lastChar);(j=isWhiteSpace(nextChar))?canOpen=!1:isNextPunctChar&&(isLastWhiteSpace||isLastPunctChar||\n(canOpen=!1));isLastWhiteSpace?openQuote=!1:isLastPunctChar&&(j||isNextPunctChar||(openQuote=!1));34===nextChar&&'\"'===t[0]&&48<=lastChar&&57>=lastChar&&(openQuote=canOpen=!1);canOpen&&openQuote&&(canOpen=isLastPunctChar,openQuote=isNextPunctChar);if(canOpen||openQuote){if(openQuote)for(j=stack.length-1;0<=j;j--){nextChar=stack[j];if(stack[j].level<thisLevel)break;if(nextChar.single===closeQuote&&stack[j].level===thisLevel){nextChar=stack[j];closeQuote?(openQuote=state.md.options.quotes[2],closeQuote=\nstate.md.options.quotes[3]):(openQuote=state.md.options.quotes[0],closeQuote=state.md.options.quotes[1]);token.content=replaceAt(token.content,t.index,closeQuote);tokens[nextChar.token].content=replaceAt(tokens[nextChar.token].content,nextChar.pos,openQuote);pos+=closeQuote.length-1;nextChar.token===i&&(pos+=openQuote.length-1);text=token.content;max=text.length;stack.length=j;continue a}}canOpen?stack.push({token:i,pos:t.index,single:closeQuote,level:thisLevel}):openQuote&&closeQuote&&(token.content=\nreplaceAt(token.content,t.index,\"’\"))}else closeQuote&&(token.content=replaceAt(token.content,t.index,\"’\"))}}}}}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_core$smartquotes\"] = function(global,require,module,exports) {\n// Convert straight quotation marks to typographic ones\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* ’ */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (tokens[j].type !== 'text') continue;\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (tokens[j].type !== 'text') continue;\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$markdown_it$lib$common$utils"]],"~:properties",["^5",["pos","token","lastIndex","level","content","length","single"]],"~:compiled-at",1591107371169,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_core$smartquotes.js\",\n\"lineCount\":7,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_core/smartquotes.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_core$smartquotes\\\"] = function(global,require,module,exports) {\\n// Convert straight quotation marks to typographic ones\\n//\\n'use strict';\\n\\n\\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\\nvar isPunctChar    = require('../common/utils').isPunctChar;\\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\\n\\nvar QUOTE_TEST_RE = /['\\\"]/;\\nvar QUOTE_RE = /['\\\"]/g;\\nvar APOSTROPHE = '\\\\u2019'; /* \\u2019 */\\n\\n\\nfunction replaceAt(str, index, ch) {\\n  return str.substr(0, index) + ch + str.substr(index + 1);\\n}\\n\\nfunction process_inlines(tokens, state) {\\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\\n\\n  stack = [];\\n\\n  for (i = 0; i < tokens.length; i++) {\\n    token = tokens[i];\\n\\n    thisLevel = tokens[i].level;\\n\\n    for (j = stack.length - 1; j >= 0; j--) {\\n      if (stack[j].level <= thisLevel) { break; }\\n    }\\n    stack.length = j + 1;\\n\\n    if (token.type !== 'text') { continue; }\\n\\n    text = token.content;\\n    pos = 0;\\n    max = text.length;\\n\\n    /*eslint no-labels:0,block-scoped-var:0*/\\n    OUTER:\\n    while (pos < max) {\\n      QUOTE_RE.lastIndex = pos;\\n      t = QUOTE_RE.exec(text);\\n      if (!t) { break; }\\n\\n      canOpen = canClose = true;\\n      pos = t.index + 1;\\n      isSingle = (t[0] === \\\"'\\\");\\n\\n      // Find previous character,\\n      // default to space if it's the beginning of the line\\n      //\\n      lastChar = 0x20;\\n\\n      if (t.index - 1 >= 0) {\\n        lastChar = text.charCodeAt(t.index - 1);\\n      } else {\\n        for (j = i - 1; j >= 0; j--) {\\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\\n          if (tokens[j].type !== 'text') continue;\\n\\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\\n          break;\\n        }\\n      }\\n\\n      // Find next character,\\n      // default to space if it's the end of the line\\n      //\\n      nextChar = 0x20;\\n\\n      if (pos < max) {\\n        nextChar = text.charCodeAt(pos);\\n      } else {\\n        for (j = i + 1; j < tokens.length; j++) {\\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\\n          if (tokens[j].type !== 'text') continue;\\n\\n          nextChar = tokens[j].content.charCodeAt(0);\\n          break;\\n        }\\n      }\\n\\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\\n\\n      isLastWhiteSpace = isWhiteSpace(lastChar);\\n      isNextWhiteSpace = isWhiteSpace(nextChar);\\n\\n      if (isNextWhiteSpace) {\\n        canOpen = false;\\n      } else if (isNextPunctChar) {\\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\\n          canOpen = false;\\n        }\\n      }\\n\\n      if (isLastWhiteSpace) {\\n        canClose = false;\\n      } else if (isLastPunctChar) {\\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\\n          canClose = false;\\n        }\\n      }\\n\\n      if (nextChar === 0x22 /* \\\" */ && t[0] === '\\\"') {\\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\\n          // special case: 1\\\"\\\" - count first quote as an inch\\n          canClose = canOpen = false;\\n        }\\n      }\\n\\n      if (canOpen && canClose) {\\n        // Replace quotes in the middle of punctuation sequence, but not\\n        // in the middle of the words, i.e.:\\n        //\\n        // 1. foo \\\" bar \\\" baz - not replaced\\n        // 2. foo-\\\"-bar-\\\"-baz - replaced\\n        // 3. foo\\\"bar\\\"baz     - not replaced\\n        //\\n        canOpen = isLastPunctChar;\\n        canClose = isNextPunctChar;\\n      }\\n\\n      if (!canOpen && !canClose) {\\n        // middle of word\\n        if (isSingle) {\\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\\n        }\\n        continue;\\n      }\\n\\n      if (canClose) {\\n        // this could be a closing quote, rewind the stack to get a match\\n        for (j = stack.length - 1; j >= 0; j--) {\\n          item = stack[j];\\n          if (stack[j].level < thisLevel) { break; }\\n          if (item.single === isSingle && stack[j].level === thisLevel) {\\n            item = stack[j];\\n\\n            if (isSingle) {\\n              openQuote = state.md.options.quotes[2];\\n              closeQuote = state.md.options.quotes[3];\\n            } else {\\n              openQuote = state.md.options.quotes[0];\\n              closeQuote = state.md.options.quotes[1];\\n            }\\n\\n            // replace token.content *before* tokens[item.token].content,\\n            // because, if they are pointing at the same token, replaceAt\\n            // could mess up indices when quote length != 1\\n            token.content = replaceAt(token.content, t.index, closeQuote);\\n            tokens[item.token].content = replaceAt(\\n              tokens[item.token].content, item.pos, openQuote);\\n\\n            pos += closeQuote.length - 1;\\n            if (item.token === i) { pos += openQuote.length - 1; }\\n\\n            text = token.content;\\n            max = text.length;\\n\\n            stack.length = j;\\n            continue OUTER;\\n          }\\n        }\\n      }\\n\\n      if (canOpen) {\\n        stack.push({\\n          token: i,\\n          pos: t.index,\\n          single: isSingle,\\n          level: thisLevel\\n        });\\n      } else if (canClose && isSingle) {\\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\\n      }\\n    }\\n  }\\n}\\n\\n\\nmodule.exports = function smartquotes(state) {\\n  /*eslint max-depth:0*/\\n  var blkIdx;\\n\\n  if (!state.md.options.typographer) { return; }\\n\\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\\n\\n    if (state.tokens[blkIdx].type !== 'inline' ||\\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\\n      continue;\\n    }\\n\\n    process_inlines(state.tokens[blkIdx].children, state);\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"replaceAt\",\"str\",\"index\",\"ch\",\"substr\",\"isWhiteSpace\",\"isPunctChar\",\"isMdAsciiPunct\",\"QUOTE_TEST_RE\",\"QUOTE_RE\",\"module.exports\",\"state\",\"blkIdx\",\"md\",\"options\",\"typographer\",\"tokens\",\"length\",\"type\",\"test\",\"content\",\"openQuote\",\"j\",\"i\",\"children\",\"stack\",\"token\",\"thisLevel\",\"level\",\"text\",\"pos\",\"max\",\"lastIndex\",\"t\",\"exec\",\"canOpen\",\"canClose\",\"isSingle\",\"lastChar\",\"charCodeAt\",\"nextChar\",\"isLastPunctChar\",\"String\",\"fromCharCode\",\"isNextPunctChar\",\"isLastWhiteSpace\",\"isNextWhiteSpace\",\"item\",\"single\",\"quotes\",\"closeQuote\",\"push\",\"APOSTROPHE\"]\n}\n"]