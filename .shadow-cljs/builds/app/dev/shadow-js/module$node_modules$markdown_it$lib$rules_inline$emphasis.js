["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_inline/emphasis.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_inline$emphasis=function(global,require,module,exports){function postProcess(state,delimiters){var i;for(i=delimiters.length-1;0<=i;i--){var startDelim=delimiters[i];if((95===startDelim.marker||42===startDelim.marker)&&-1!==startDelim.end){var endDelim=delimiters[startDelim.end];var isStrong=0<i&&delimiters[i-1].end===startDelim.end+1&&delimiters[i-1].token===startDelim.token-1&&delimiters[startDelim.end+1].token===endDelim.token+1&&delimiters[i-\n1].marker===startDelim.marker;var ch=String.fromCharCode(startDelim.marker);var token=state.tokens[startDelim.token];token.type=isStrong?\"strong_open\":\"em_open\";token.tag=isStrong?\"strong\":\"em\";token.nesting=1;token.markup=isStrong?ch+ch:ch;token.content=\"\";token=state.tokens[endDelim.token];token.type=isStrong?\"strong_close\":\"em_close\";token.tag=isStrong?\"strong\":\"em\";token.nesting=-1;token.markup=isStrong?ch+ch:ch;token.content=\"\";isStrong&&(state.tokens[delimiters[i-1].token].content=\"\",state.tokens[delimiters[startDelim.end+\n1].token].content=\"\",i--)}}}module.exports.tokenize=function(state,silent){var marker=state.src.charCodeAt(state.pos);if(silent||95!==marker&&42!==marker)return!1;var scanned=state.scanDelims(state.pos,42===marker);for(silent=0;silent<scanned.length;silent++){var token=state.push(\"text\",\"\",0);token.content=String.fromCharCode(marker);state.delimiters.push({marker:marker,length:scanned.length,jump:silent,token:state.tokens.length-1,end:-1,open:scanned.can_open,close:scanned.can_close})}state.pos+=\nscanned.length;return!0};module.exports.postProcess=function(state){var curr,tokens_meta=state.tokens_meta,max=state.tokens_meta.length;postProcess(state,state.delimiters);for(curr=0;curr<max;curr++)tokens_meta[curr]&&tokens_meta[curr].delimiters&&postProcess(state,tokens_meta[curr].delimiters)}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$emphasis\"] = function(global,require,module,exports) {\n// Process *this* and _that_\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // An amount of characters before this one that's equivalent to\n      // current one. In plain English: if this delimiter does not open\n      // an emphasis, neither do previous `jump` characters.\n      //\n      // Used to skip sequences like \"*****\" in one step, for 1st asterisk\n      // value will be 0, for 2nd it's 1 and so on.\n      //\n      jump:   i,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      max = delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&\n               delimiters[i - 1].marker === startDelim.marker;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["pos","token","tokenize","markup","nesting","jump","tag","content","length","close","type","postProcess","marker","open","end"]],"~:compiled-at",1591107371176,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_inline$emphasis.js\",\n\"lineCount\":4,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_inline/emphasis.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_inline$emphasis\\\"] = function(global,require,module,exports) {\\n// Process *this* and _that_\\n//\\n'use strict';\\n\\n\\n// Insert each marker as a separate text token, and add it to delimiter list\\n//\\nmodule.exports.tokenize = function emphasis(state, silent) {\\n  var i, scanned, token,\\n      start = state.pos,\\n      marker = state.src.charCodeAt(start);\\n\\n  if (silent) { return false; }\\n\\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\\n\\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\\n\\n  for (i = 0; i < scanned.length; i++) {\\n    token         = state.push('text', '', 0);\\n    token.content = String.fromCharCode(marker);\\n\\n    state.delimiters.push({\\n      // Char code of the starting marker (number).\\n      //\\n      marker: marker,\\n\\n      // Total length of these series of delimiters.\\n      //\\n      length: scanned.length,\\n\\n      // An amount of characters before this one that's equivalent to\\n      // current one. In plain English: if this delimiter does not open\\n      // an emphasis, neither do previous `jump` characters.\\n      //\\n      // Used to skip sequences like \\\"*****\\\" in one step, for 1st asterisk\\n      // value will be 0, for 2nd it's 1 and so on.\\n      //\\n      jump:   i,\\n\\n      // A position of the token this delimiter corresponds to.\\n      //\\n      token:  state.tokens.length - 1,\\n\\n      // If this delimiter is matched as a valid opener, `end` will be\\n      // equal to its position, otherwise it's `-1`.\\n      //\\n      end:    -1,\\n\\n      // Boolean flags that determine if this delimiter could open or close\\n      // an emphasis.\\n      //\\n      open:   scanned.can_open,\\n      close:  scanned.can_close\\n    });\\n  }\\n\\n  state.pos += scanned.length;\\n\\n  return true;\\n};\\n\\n\\nfunction postProcess(state, delimiters) {\\n  var i,\\n      startDelim,\\n      endDelim,\\n      token,\\n      ch,\\n      isStrong,\\n      max = delimiters.length;\\n\\n  for (i = max - 1; i >= 0; i--) {\\n    startDelim = delimiters[i];\\n\\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\\n      continue;\\n    }\\n\\n    // Process only opening markers\\n    if (startDelim.end === -1) {\\n      continue;\\n    }\\n\\n    endDelim = delimiters[startDelim.end];\\n\\n    // If the previous delimiter has the same marker and is adjacent to this one,\\n    // merge those into one strong delimiter.\\n    //\\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\\n    //\\n    isStrong = i > 0 &&\\n               delimiters[i - 1].end === startDelim.end + 1 &&\\n               delimiters[i - 1].token === startDelim.token - 1 &&\\n               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&\\n               delimiters[i - 1].marker === startDelim.marker;\\n\\n    ch = String.fromCharCode(startDelim.marker);\\n\\n    token         = state.tokens[startDelim.token];\\n    token.type    = isStrong ? 'strong_open' : 'em_open';\\n    token.tag     = isStrong ? 'strong' : 'em';\\n    token.nesting = 1;\\n    token.markup  = isStrong ? ch + ch : ch;\\n    token.content = '';\\n\\n    token         = state.tokens[endDelim.token];\\n    token.type    = isStrong ? 'strong_close' : 'em_close';\\n    token.tag     = isStrong ? 'strong' : 'em';\\n    token.nesting = -1;\\n    token.markup  = isStrong ? ch + ch : ch;\\n    token.content = '';\\n\\n    if (isStrong) {\\n      state.tokens[delimiters[i - 1].token].content = '';\\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\\n      i--;\\n    }\\n  }\\n}\\n\\n\\n// Walk through delimiter list and replace text tokens with tags\\n//\\nmodule.exports.postProcess = function emphasis(state) {\\n  var curr,\\n      tokens_meta = state.tokens_meta,\\n      max = state.tokens_meta.length;\\n\\n  postProcess(state, state.delimiters);\\n\\n  for (curr = 0; curr < max; curr++) {\\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\\n      postProcess(state, tokens_meta[curr].delimiters);\\n    }\\n  }\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"postProcess\",\"state\",\"delimiters\",\"i\",\"length\",\"startDelim\",\"marker\",\"end\",\"endDelim\",\"isStrong\",\"token\",\"ch\",\"String\",\"fromCharCode\",\"tokens\",\"type\",\"tag\",\"nesting\",\"markup\",\"content\",\"tokenize\",\"module.exports.tokenize\",\"silent\",\"src\",\"charCodeAt\",\"pos\",\"scanned\",\"scanDelims\",\"push\",\"jump\",\"open\",\"can_open\",\"close\",\"can_close\",\"module.exports.postProcess\",\"curr\",\"tokens_meta\",\"max\"]\n}\n"]