["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/markdown-it/lib/rules_block/reference.js"],"~:js","shadow$provide.module$node_modules$markdown_it$lib$rules_block$reference=function(global,require,module,exports){var normalizeReference=require(\"module$node_modules$markdown_it$lib$common$utils\").normalizeReference,isSpace=require(\"module$node_modules$markdown_it$lib$common$utils\").isSpace;module.exports=function(state,startLine,_endLine,silent){var destEndPos,start,lines=0;var endLine=state.bMarks[startLine]+state.tShift[startLine];var i=state.eMarks[startLine];var href=startLine+1;if(4<=state.sCount[startLine]-\nstate.blkIndent||91!==state.src.charCodeAt(endLine))return!1;for(;++endLine<i;)if(93===state.src.charCodeAt(endLine)&&92!==state.src.charCodeAt(endLine-1)){if(endLine+1===i||58!==state.src.charCodeAt(endLine+1))return!1;break}endLine=state.lineMax;var str=state.md.block.ruler.getRules(\"reference\");_endLine=state.parentType;for(state.parentType=\"reference\";href<endLine&&!state.isEmpty(href);href++)if(!(3<state.sCount[href]-state.blkIndent||0>state.sCount[href])){var destEndLineNo=!1;i=0;for(destEndPos=\nstr.length;i<destEndPos;i++)if(str[i](state,href,endLine,!0)){destEndLineNo=!0;break}if(destEndLineNo)break}str=state.getLines(startLine,href,state.blkIndent,!1).trim();i=str.length;for(endLine=1;endLine<i;endLine++){var ch=str.charCodeAt(endLine);if(91===ch)return!1;if(93===ch){var label=endLine;break}else 10===ch?lines++:92===ch&&(endLine++,endLine<i&&10===str.charCodeAt(endLine)&&lines++)}if(0>label||58!==str.charCodeAt(label+1))return!1;for(endLine=label+2;endLine<i;endLine++)if(ch=str.charCodeAt(endLine),\n10===ch)lines++;else if(!isSpace(ch))break;ch=state.md.helpers.parseLinkDestination(str,endLine,i);if(!ch.ok)return!1;href=state.md.normalizeLink(ch.str);if(!state.md.validateLink(href))return!1;endLine=ch.pos;lines+=ch.lines;destEndPos=endLine;destEndLineNo=lines;for(start=endLine;endLine<i;endLine++)if(ch=str.charCodeAt(endLine),10===ch)lines++;else if(!isSpace(ch))break;ch=state.md.helpers.parseLinkTitle(str,endLine,i);endLine<i&&start!==endLine&&ch.ok?(start=ch.str,endLine=ch.pos,lines+=ch.lines):\n(start=\"\",endLine=destEndPos,lines=destEndLineNo);for(;endLine<i;){ch=str.charCodeAt(endLine);if(!isSpace(ch))break;endLine++}if(endLine<i&&10!==str.charCodeAt(endLine)&&start)for(start=\"\",endLine=destEndPos,lines=destEndLineNo;endLine<i;){ch=str.charCodeAt(endLine);if(!isSpace(ch))break;endLine++}if(endLine<i&&10!==str.charCodeAt(endLine))return!1;label=normalizeReference(str.slice(1,label));if(!label)return!1;if(silent)return!0;\"undefined\"===typeof state.env.references&&(state.env.references={});\n\"undefined\"===typeof state.env.references[label]&&(state.env.references[label]={title:start,href:href});state.parentType=_endLine;state.line=startLine+lines+1;return!0}}","~:source","shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$reference\"] = function(global,require,module,exports) {\n'use strict';\n\n\nvar normalizeReference   = require('../common/utils').normalizeReference;\nvar isSpace              = require('../common/utils').isSpace;\n\n\nmodule.exports = function reference(state, startLine, _endLine, silent) {\n  var ch,\n      destEndPos,\n      destEndLineNo,\n      endLine,\n      href,\n      i,\n      l,\n      label,\n      labelEnd,\n      oldParentType,\n      res,\n      start,\n      str,\n      terminate,\n      terminatorRules,\n      title,\n      lines = 0,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine],\n      nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\n\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\n  while (++pos < max) {\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\ */) {\n      if (pos + 1 === max) { return false; }\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\n      break;\n    }\n  }\n\n  endLine = state.lineMax;\n\n  // jump line-by-line until empty one or EOF\n  terminatorRules = state.md.block.ruler.getRules('reference');\n\n  oldParentType = state.parentType;\n  state.parentType = 'reference';\n\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue; }\n\n    // Some tags can terminate paragraph without empty line.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n  }\n\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  max = str.length;\n\n  for (pos = 1; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      lines++;\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        lines++;\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!res.ok) { return false; }\n\n  href = state.md.normalizeLink(res.str);\n  if (!state.md.validateLink(href)) { return false; }\n\n  pos = res.pos;\n  lines += res.lines;\n\n  // save cursor state, we could require to rollback later\n  destEndPos = pos;\n  destEndLineNo = lines;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  start = pos;\n  for (; pos < max; pos++) {\n    ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      lines++;\n    } else if (isSpace(ch)) {\n      /*eslint no-empty:0*/\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\n  if (pos < max && start !== pos && res.ok) {\n    title = res.str;\n    pos = res.pos;\n    lines += res.lines;\n  } else {\n    title = '';\n    pos = destEndPos;\n    lines = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) { break; }\n    pos++;\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      lines = destEndLineNo;\n      while (pos < max) {\n        ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /*istanbul ignore if*/\n  if (silent) { return true; }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title: title, href: href };\n  }\n\n  state.parentType = oldParentType;\n\n  state.line = startLine + lines + 1;\n  return true;\n};\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js","~$module$node_modules$markdown_it$lib$common$utils"]],"~:properties",["^5",["references","href","line","title","parentType"]],"~:compiled-at",1591107371172,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$markdown_it$lib$rules_block$reference.js\",\n\"lineCount\":6,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/markdown-it/lib/rules_block/reference.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$markdown_it$lib$rules_block$reference\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\n\\nvar normalizeReference   = require('../common/utils').normalizeReference;\\nvar isSpace              = require('../common/utils').isSpace;\\n\\n\\nmodule.exports = function reference(state, startLine, _endLine, silent) {\\n  var ch,\\n      destEndPos,\\n      destEndLineNo,\\n      endLine,\\n      href,\\n      i,\\n      l,\\n      label,\\n      labelEnd,\\n      oldParentType,\\n      res,\\n      start,\\n      str,\\n      terminate,\\n      terminatorRules,\\n      title,\\n      lines = 0,\\n      pos = state.bMarks[startLine] + state.tShift[startLine],\\n      max = state.eMarks[startLine],\\n      nextLine = startLine + 1;\\n\\n  // if it's indented more than 3 spaces, it should be a code block\\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\\n\\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }\\n\\n  // Simple check to quickly interrupt scan on [link](url) at the start of line.\\n  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54\\n  while (++pos < max) {\\n    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&\\n        state.src.charCodeAt(pos - 1) !== 0x5C/* \\\\ */) {\\n      if (pos + 1 === max) { return false; }\\n      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }\\n      break;\\n    }\\n  }\\n\\n  endLine = state.lineMax;\\n\\n  // jump line-by-line until empty one or EOF\\n  terminatorRules = state.md.block.ruler.getRules('reference');\\n\\n  oldParentType = state.parentType;\\n  state.parentType = 'reference';\\n\\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\\n    // this would be a code block normally, but after paragraph\\n    // it's considered a lazy continuation regardless of what's there\\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }\\n\\n    // quirk for blockquotes, this line should already be checked by that rule\\n    if (state.sCount[nextLine] < 0) { continue; }\\n\\n    // Some tags can terminate paragraph without empty line.\\n    terminate = false;\\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\\n        terminate = true;\\n        break;\\n      }\\n    }\\n    if (terminate) { break; }\\n  }\\n\\n  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\\n  max = str.length;\\n\\n  for (pos = 1; pos < max; pos++) {\\n    ch = str.charCodeAt(pos);\\n    if (ch === 0x5B /* [ */) {\\n      return false;\\n    } else if (ch === 0x5D /* ] */) {\\n      labelEnd = pos;\\n      break;\\n    } else if (ch === 0x0A /* \\\\n */) {\\n      lines++;\\n    } else if (ch === 0x5C /* \\\\ */) {\\n      pos++;\\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\\n        lines++;\\n      }\\n    }\\n  }\\n\\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }\\n\\n  // [label]:   destination   'title'\\n  //         ^^^ skip optional whitespace here\\n  for (pos = labelEnd + 2; pos < max; pos++) {\\n    ch = str.charCodeAt(pos);\\n    if (ch === 0x0A) {\\n      lines++;\\n    } else if (isSpace(ch)) {\\n      /*eslint no-empty:0*/\\n    } else {\\n      break;\\n    }\\n  }\\n\\n  // [label]:   destination   'title'\\n  //            ^^^^^^^^^^^ parse this\\n  res = state.md.helpers.parseLinkDestination(str, pos, max);\\n  if (!res.ok) { return false; }\\n\\n  href = state.md.normalizeLink(res.str);\\n  if (!state.md.validateLink(href)) { return false; }\\n\\n  pos = res.pos;\\n  lines += res.lines;\\n\\n  // save cursor state, we could require to rollback later\\n  destEndPos = pos;\\n  destEndLineNo = lines;\\n\\n  // [label]:   destination   'title'\\n  //                       ^^^ skipping those spaces\\n  start = pos;\\n  for (; pos < max; pos++) {\\n    ch = str.charCodeAt(pos);\\n    if (ch === 0x0A) {\\n      lines++;\\n    } else if (isSpace(ch)) {\\n      /*eslint no-empty:0*/\\n    } else {\\n      break;\\n    }\\n  }\\n\\n  // [label]:   destination   'title'\\n  //                          ^^^^^^^ parse this\\n  res = state.md.helpers.parseLinkTitle(str, pos, max);\\n  if (pos < max && start !== pos && res.ok) {\\n    title = res.str;\\n    pos = res.pos;\\n    lines += res.lines;\\n  } else {\\n    title = '';\\n    pos = destEndPos;\\n    lines = destEndLineNo;\\n  }\\n\\n  // skip trailing spaces until the rest of the line\\n  while (pos < max) {\\n    ch = str.charCodeAt(pos);\\n    if (!isSpace(ch)) { break; }\\n    pos++;\\n  }\\n\\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\\n    if (title) {\\n      // garbage at the end of the line after title,\\n      // but it could still be a valid reference if we roll back\\n      title = '';\\n      pos = destEndPos;\\n      lines = destEndLineNo;\\n      while (pos < max) {\\n        ch = str.charCodeAt(pos);\\n        if (!isSpace(ch)) { break; }\\n        pos++;\\n      }\\n    }\\n  }\\n\\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\\n    // garbage at the end of the line\\n    return false;\\n  }\\n\\n  label = normalizeReference(str.slice(1, labelEnd));\\n  if (!label) {\\n    // CommonMark 0.20 disallows empty labels\\n    return false;\\n  }\\n\\n  // Reference can not terminate anything. This check is for safety only.\\n  /*istanbul ignore if*/\\n  if (silent) { return true; }\\n\\n  if (typeof state.env.references === 'undefined') {\\n    state.env.references = {};\\n  }\\n  if (typeof state.env.references[label] === 'undefined') {\\n    state.env.references[label] = { title: title, href: href };\\n  }\\n\\n  state.parentType = oldParentType;\\n\\n  state.line = startLine + lines + 1;\\n  return true;\\n};\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"normalizeReference\",\"isSpace\",\"module.exports\",\"state\",\"startLine\",\"_endLine\",\"silent\",\"destEndPos\",\"start\",\"lines\",\"pos\",\"bMarks\",\"tShift\",\"max\",\"eMarks\",\"nextLine\",\"sCount\",\"blkIndent\",\"src\",\"charCodeAt\",\"endLine\",\"lineMax\",\"terminatorRules\",\"md\",\"block\",\"ruler\",\"getRules\",\"oldParentType\",\"parentType\",\"isEmpty\",\"terminate\",\"i\",\"l\",\"length\",\"str\",\"getLines\",\"trim\",\"ch\",\"labelEnd\",\"res\",\"helpers\",\"parseLinkDestination\",\"ok\",\"href\",\"normalizeLink\",\"validateLink\",\"destEndLineNo\",\"parseLinkTitle\",\"title\",\"label\",\"slice\",\"env\",\"references\",\"line\"]\n}\n"]