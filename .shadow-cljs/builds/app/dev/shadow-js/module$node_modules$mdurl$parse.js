["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/mdurl/parse.js"],"~:js","shadow$provide.module$node_modules$mdurl$parse=function(global,require,module,exports){function Url(){this.pathname=this.search=this.hash=this.hostname=this.port=this.auth=this.slashes=this.protocol=null}var protocolPattern=/^([a-z0-9.+-]+:)/i,portPattern=/:[0-9]*$/,simplePathPattern=/^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/;global=\"{}|\\\\^`\".split(\"\").concat('\\x3c\\x3e\"` \\r\\n\\t'.split(\"\"));global=[\"'\"].concat(global);var nonHostChars=[\"%\",\"/\",\"?\",\";\",\"#\"].concat(global),hostEndingChars=[\"/\",\"?\",\"#\"],hostnamePartPattern=\n/^[+a-z0-9A-Z_-]{0,63}$/,hostnamePartStart=/^([+a-z0-9A-Z_-]{0,63})(.*)$/,hostlessProtocol={javascript:!0,\"javascript:\":!0},slashedProtocol={http:!0,https:!0,ftp:!0,gopher:!0,file:!0,\"http:\":!0,\"https:\":!0,\"ftp:\":!0,\"gopher:\":!0,\"file:\":!0};Url.prototype.parse=function(url,slashesDenoteHost){var l,slashes;var rest=url.trim();if(!slashesDenoteHost&&1===url.split(\"#\").length&&(url=simplePathPattern.exec(rest)))return this.pathname=url[1],url[2]&&(this.search=url[2]),this;if(url=protocolPattern.exec(rest)){url=\nurl[0];var lowerProto=url.toLowerCase();this.protocol=url;rest=rest.substr(url.length)}if(slashesDenoteHost||url||rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/))!(slashes=\"//\"===rest.substr(0,2))||url&&hostlessProtocol[url]||(rest=rest.substr(2),this.slashes=!0);if(!hostlessProtocol[url]&&(slashes||url&&!slashedProtocol[url])){slashes=-1;for(slashesDenoteHost=0;slashesDenoteHost<hostEndingChars.length;slashesDenoteHost++)url=rest.indexOf(hostEndingChars[slashesDenoteHost]),-1!==url&&(-1===slashes||url<slashes)&&\n(slashes=url);slashes=-1===slashes?rest.lastIndexOf(\"@\"):rest.lastIndexOf(\"@\",slashes);-1!==slashes&&(slashesDenoteHost=rest.slice(0,slashes),rest=rest.slice(slashes+1),this.auth=slashesDenoteHost);slashes=-1;for(slashesDenoteHost=0;slashesDenoteHost<nonHostChars.length;slashesDenoteHost++)url=rest.indexOf(nonHostChars[slashesDenoteHost]),-1!==url&&(-1===slashes||url<slashes)&&(slashes=url);-1===slashes&&(slashes=rest.length);\":\"===rest[slashes-1]&&slashes--;slashesDenoteHost=rest.slice(0,slashes);\nrest=rest.slice(slashes);this.parseHost(slashesDenoteHost);this.hostname=this.hostname||\"\";slashes=\"[\"===this.hostname[0]&&\"]\"===this.hostname[this.hostname.length-1];if(!slashes){var hostparts=this.hostname.split(/\\./);slashesDenoteHost=0;for(l=hostparts.length;slashesDenoteHost<l;slashesDenoteHost++)if((url=hostparts[slashesDenoteHost])&&!url.match(hostnamePartPattern)){for(var newpart=\"\",j=0,k=url.length;j<k;j++)newpart=127<url.charCodeAt(j)?newpart+\"x\":newpart+url[j];if(!newpart.match(hostnamePartPattern)){l=\nhostparts.slice(0,slashesDenoteHost);slashesDenoteHost=hostparts.slice(slashesDenoteHost+1);if(url=url.match(hostnamePartStart))l.push(url[1]),slashesDenoteHost.unshift(url[2]);slashesDenoteHost.length&&(rest=slashesDenoteHost.join(\".\")+rest);this.hostname=l.join(\".\");break}}}255<this.hostname.length&&(this.hostname=\"\");slashes&&(this.hostname=this.hostname.substr(1,this.hostname.length-2))}slashesDenoteHost=rest.indexOf(\"#\");-1!==slashesDenoteHost&&(this.hash=rest.substr(slashesDenoteHost),rest=\nrest.slice(0,slashesDenoteHost));slashesDenoteHost=rest.indexOf(\"?\");-1!==slashesDenoteHost&&(this.search=rest.substr(slashesDenoteHost),rest=rest.slice(0,slashesDenoteHost));rest&&(this.pathname=rest);slashedProtocol[lowerProto]&&this.hostname&&!this.pathname&&(this.pathname=\"\");return this};Url.prototype.parseHost=function(host){var port=portPattern.exec(host);port&&(port=port[0],\":\"!==port&&(this.port=port.substr(1)),host=host.substr(0,host.length-port.length));host&&(this.hostname=host)};module.exports=\nfunction(url,slashesDenoteHost){if(url&&url instanceof Url)return url;var u=new Url;u.parse(url,slashesDenoteHost);return u}}","~:source","shadow$provide[\"module$node_modules$mdurl$parse\"] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = [ '\\'' ].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\n    hostEndingChars = [ '/', '?', '#' ],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    /* eslint-disable no-script-url */\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n    /* eslint-enable no-script-url */\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l, lowerProto, hec, slashes,\n      rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nmodule.exports = urlParse;\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$shadow.js"]],"~:properties",["^5",["hostname","protocol","slashes","hash","pathname","auth","port","parse","parseHost","search"]],"~:compiled-at",1591107371154,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$mdurl$parse.js\",\n\"lineCount\":8,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/mdurl/parse.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$mdurl$parse\\\"] = function(global,require,module,exports) {\\n// Copyright Joyent, Inc. and other Node contributors.\\n//\\n// Permission is hereby granted, free of charge, to any person obtaining a\\n// copy of this software and associated documentation files (the\\n// \\\"Software\\\"), to deal in the Software without restriction, including\\n// without limitation the rights to use, copy, modify, merge, publish,\\n// distribute, sublicense, and/or sell copies of the Software, and to permit\\n// persons to whom the Software is furnished to do so, subject to the\\n// following conditions:\\n//\\n// The above copyright notice and this permission notice shall be included\\n// in all copies or substantial portions of the Software.\\n//\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\\n\\n'use strict';\\n\\n//\\n// Changes from joyent/node:\\n//\\n// 1. No leading slash in paths,\\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\\n//\\n// 2. Backslashes are not replaced with slashes,\\n//    so `http:\\\\\\\\example.org\\\\` is treated like a relative path\\n//\\n// 3. Trailing colon is treated like a part of the path,\\n//    i.e. in `http://example.org:foo` pathname is `:foo`\\n//\\n// 4. Nothing is URL-encoded in the resulting object,\\n//    (in joyent/node some chars in auth and paths are encoded)\\n//\\n// 5. `url.parse()` does not have `parseQueryString` argument\\n//\\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\\n//    which can be constructed using other parts of the url.\\n//\\n\\n\\nfunction Url() {\\n  this.protocol = null;\\n  this.slashes = null;\\n  this.auth = null;\\n  this.port = null;\\n  this.hostname = null;\\n  this.hash = null;\\n  this.search = null;\\n  this.pathname = null;\\n}\\n\\n// Reference: RFC 3986, RFC 1808, RFC 2396\\n\\n// define these here so at least they only have to be\\n// compiled once on the first module load.\\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\\n    portPattern = /:[0-9]*$/,\\n\\n    // Special case for a simple path URL\\n    simplePathPattern = /^(\\\\/\\\\/?(?!\\\\/)[^\\\\?\\\\s]*)(\\\\?[^\\\\s]*)?$/,\\n\\n    // RFC 2396: characters reserved for delimiting URLs.\\n    // We actually just auto-escape these.\\n    delims = [ '<', '>', '\\\"', '`', ' ', '\\\\r', '\\\\n', '\\\\t' ],\\n\\n    // RFC 2396: characters not allowed for various reasons.\\n    unwise = [ '{', '}', '|', '\\\\\\\\', '^', '`' ].concat(delims),\\n\\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\\n    autoEscape = [ '\\\\'' ].concat(unwise),\\n    // Characters that are never ever allowed in a hostname.\\n    // Note that any invalid chars are also handled, but these\\n    // are the ones that are *expected* to be seen, so we fast-path\\n    // them.\\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\\n    hostEndingChars = [ '/', '?', '#' ],\\n    hostnameMaxLen = 255,\\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\\n    // protocols that can allow \\\"unsafe\\\" and \\\"unwise\\\" chars.\\n    /* eslint-disable no-script-url */\\n    // protocols that never have a hostname.\\n    hostlessProtocol = {\\n      'javascript': true,\\n      'javascript:': true\\n    },\\n    // protocols that always contain a // bit.\\n    slashedProtocol = {\\n      'http': true,\\n      'https': true,\\n      'ftp': true,\\n      'gopher': true,\\n      'file': true,\\n      'http:': true,\\n      'https:': true,\\n      'ftp:': true,\\n      'gopher:': true,\\n      'file:': true\\n    };\\n    /* eslint-enable no-script-url */\\n\\nfunction urlParse(url, slashesDenoteHost) {\\n  if (url && url instanceof Url) { return url; }\\n\\n  var u = new Url();\\n  u.parse(url, slashesDenoteHost);\\n  return u;\\n}\\n\\nUrl.prototype.parse = function(url, slashesDenoteHost) {\\n  var i, l, lowerProto, hec, slashes,\\n      rest = url;\\n\\n  // trim before proceeding.\\n  // This is to support parse stuff like \\\"  http://foo.com  \\\\n\\\"\\n  rest = rest.trim();\\n\\n  if (!slashesDenoteHost && url.split('#').length === 1) {\\n    // Try fast path regexp\\n    var simplePath = simplePathPattern.exec(rest);\\n    if (simplePath) {\\n      this.pathname = simplePath[1];\\n      if (simplePath[2]) {\\n        this.search = simplePath[2];\\n      }\\n      return this;\\n    }\\n  }\\n\\n  var proto = protocolPattern.exec(rest);\\n  if (proto) {\\n    proto = proto[0];\\n    lowerProto = proto.toLowerCase();\\n    this.protocol = proto;\\n    rest = rest.substr(proto.length);\\n  }\\n\\n  // figure out if it's got a host\\n  // user@server is *always* interpreted as a hostname, and url\\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\\n  // how the browser resolves relative URLs.\\n  if (slashesDenoteHost || proto || rest.match(/^\\\\/\\\\/[^@\\\\/]+@[^@\\\\/]+/)) {\\n    slashes = rest.substr(0, 2) === '//';\\n    if (slashes && !(proto && hostlessProtocol[proto])) {\\n      rest = rest.substr(2);\\n      this.slashes = true;\\n    }\\n  }\\n\\n  if (!hostlessProtocol[proto] &&\\n      (slashes || (proto && !slashedProtocol[proto]))) {\\n\\n    // there's a hostname.\\n    // the first instance of /, ?, ;, or # ends the host.\\n    //\\n    // If there is an @ in the hostname, then non-host chars *are* allowed\\n    // to the left of the last @ sign, unless some host-ending character\\n    // comes *before* the @-sign.\\n    // URLs are obnoxious.\\n    //\\n    // ex:\\n    // http://a@b@c/ => user:a@b host:c\\n    // http://a@b?@c => user:a host:c path:/?@c\\n\\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\\n    // Review our test case against browsers more comprehensively.\\n\\n    // find the first instance of any hostEndingChars\\n    var hostEnd = -1;\\n    for (i = 0; i < hostEndingChars.length; i++) {\\n      hec = rest.indexOf(hostEndingChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\\n        hostEnd = hec;\\n      }\\n    }\\n\\n    // at this point, either we have an explicit point where the\\n    // auth portion cannot go past, or the last @ char is the decider.\\n    var auth, atSign;\\n    if (hostEnd === -1) {\\n      // atSign can be anywhere.\\n      atSign = rest.lastIndexOf('@');\\n    } else {\\n      // atSign must be in auth portion.\\n      // http://a@b/c@d => host:b auth:a path:/c@d\\n      atSign = rest.lastIndexOf('@', hostEnd);\\n    }\\n\\n    // Now we have a portion which is definitely the auth.\\n    // Pull that off.\\n    if (atSign !== -1) {\\n      auth = rest.slice(0, atSign);\\n      rest = rest.slice(atSign + 1);\\n      this.auth = auth;\\n    }\\n\\n    // the host is the remaining to the left of the first non-host char\\n    hostEnd = -1;\\n    for (i = 0; i < nonHostChars.length; i++) {\\n      hec = rest.indexOf(nonHostChars[i]);\\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\\n        hostEnd = hec;\\n      }\\n    }\\n    // if we still have not hit it, then the entire thing is a host.\\n    if (hostEnd === -1) {\\n      hostEnd = rest.length;\\n    }\\n\\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\\n    var host = rest.slice(0, hostEnd);\\n    rest = rest.slice(hostEnd);\\n\\n    // pull out port.\\n    this.parseHost(host);\\n\\n    // we've indicated that there is a hostname,\\n    // so even if it's empty, it has to be present.\\n    this.hostname = this.hostname || '';\\n\\n    // if hostname begins with [ and ends with ]\\n    // assume that it's an IPv6 address.\\n    var ipv6Hostname = this.hostname[0] === '[' &&\\n        this.hostname[this.hostname.length - 1] === ']';\\n\\n    // validate a little.\\n    if (!ipv6Hostname) {\\n      var hostparts = this.hostname.split(/\\\\./);\\n      for (i = 0, l = hostparts.length; i < l; i++) {\\n        var part = hostparts[i];\\n        if (!part) { continue; }\\n        if (!part.match(hostnamePartPattern)) {\\n          var newpart = '';\\n          for (var j = 0, k = part.length; j < k; j++) {\\n            if (part.charCodeAt(j) > 127) {\\n              // we replace non-ASCII char with a temporary placeholder\\n              // we need this to make sure size of hostname is not\\n              // broken by replacing non-ASCII by nothing\\n              newpart += 'x';\\n            } else {\\n              newpart += part[j];\\n            }\\n          }\\n          // we test again with ASCII char only\\n          if (!newpart.match(hostnamePartPattern)) {\\n            var validParts = hostparts.slice(0, i);\\n            var notHost = hostparts.slice(i + 1);\\n            var bit = part.match(hostnamePartStart);\\n            if (bit) {\\n              validParts.push(bit[1]);\\n              notHost.unshift(bit[2]);\\n            }\\n            if (notHost.length) {\\n              rest = notHost.join('.') + rest;\\n            }\\n            this.hostname = validParts.join('.');\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (this.hostname.length > hostnameMaxLen) {\\n      this.hostname = '';\\n    }\\n\\n    // strip [ and ] from the hostname\\n    // the host field still retains them, though\\n    if (ipv6Hostname) {\\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\\n    }\\n  }\\n\\n  // chop off from the tail first.\\n  var hash = rest.indexOf('#');\\n  if (hash !== -1) {\\n    // got a fragment string.\\n    this.hash = rest.substr(hash);\\n    rest = rest.slice(0, hash);\\n  }\\n  var qm = rest.indexOf('?');\\n  if (qm !== -1) {\\n    this.search = rest.substr(qm);\\n    rest = rest.slice(0, qm);\\n  }\\n  if (rest) { this.pathname = rest; }\\n  if (slashedProtocol[lowerProto] &&\\n      this.hostname && !this.pathname) {\\n    this.pathname = '';\\n  }\\n\\n  return this;\\n};\\n\\nUrl.prototype.parseHost = function(host) {\\n  var port = portPattern.exec(host);\\n  if (port) {\\n    port = port[0];\\n    if (port !== ':') {\\n      this.port = port.substr(1);\\n    }\\n    host = host.substr(0, host.length - port.length);\\n  }\\n  if (host) { this.hostname = host; }\\n};\\n\\nmodule.exports = urlParse;\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"Url\",\"pathname\",\"search\",\"hash\",\"hostname\",\"port\",\"auth\",\"slashes\",\"protocol\",\"protocolPattern\",\"portPattern\",\"simplePathPattern\",\"unwise\",\"concat\",\"delims\",\"autoEscape\",\"nonHostChars\",\"hostEndingChars\",\"hostnamePartPattern\",\"hostnamePartStart\",\"hostlessProtocol\",\"slashedProtocol\",\"prototype\",\"parse\",\"Url.prototype.parse\",\"url\",\"slashesDenoteHost\",\"l\",\"rest\",\"trim\",\"split\",\"length\",\"simplePath\",\"exec\",\"proto\",\"lowerProto\",\"toLowerCase\",\"substr\",\"match\",\"hostEnd\",\"i\",\"hec\",\"indexOf\",\"atSign\",\"lastIndexOf\",\"slice\",\"host\",\"parseHost\",\"ipv6Hostname\",\"hostparts\",\"part\",\"newpart\",\"j\",\"k\",\"charCodeAt\",\"validParts\",\"notHost\",\"bit\",\"push\",\"unshift\",\"join\",\"hostnameMaxLen\",\"qm\",\"Url.prototype.parseHost\",\"urlParse\",\"u\"]\n}\n"]